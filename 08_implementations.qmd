---
toc-title: "Chapter 8"
---

# Implementations {#sec-implementations}

::: {.content-visible when-format="html"}
{{< include style/macros-html.md >}}
{{< include style/macros.md >}}
:::

## Prototype: *equiv.io* {#sec-equivio}

The “Linear-Time–Branching-Time Spectroscope” on {{<equivio>}} is a small webtool to check equivalence relations on CCS processes.

### Usage {#sec-equivio-usage}

The standard workflow of {{<equivio>}} is to specify processes in CCS and then compare them with respect to equivalence spectra.
This is mainly achieved by writing everything into the source editor on the left. 
The specific order of definitions, queries, and declarations in the source generally makes no difference.

{{< paragraph_heading "Process syntax." >}}
CCS processes are written according to the grammar in @def-ccs, with the concrete syntax for subterms following @tbl-ccs-syntax.

| Construct       | Tool syntax      | CCS                                   |
|-----------------|------------------|-----------------------|
| Input prefix    | `a.P`            | $\ccsprefix{\literal a} P$            |
| Output prefix   | `a!P`            | $\ccsprefix{\coaction{\literal a}} P$ |
| Internal action | `tau.P`          | $\ccsprefix{\tau} P$                  |
| Null process    | `0`              | $\ccsnull$                            |
| Recursion       | `P_Name`         | $\literal{P_{Name}}$                  |
| Choice          | `P1 + P2`        | $P_1 \ccschoice P_2$                  |
| Parallel        | `P1 | P2`        | $P_1 \ccspar P_2$                     |
| Restriction     | `P \ {a1, a2}`   | $P_1 \ccsrestrict \set{\literal{a_1}, \literal{a_2}}$ |

: Concrete ASCII syntax for CCS terms {#tbl-ccs-syntax fig-pos='b'}

Literals for actions and process names combine Latin letters, numbers, and underscores in the usual way.

Top-level process definitions are written `X = P`, expressing that $\ccsasg(\literal{X}) \defeq P$ in the semantics (@def-ccs-semantics).
The right-hand pane shows the resulting transition system.

The syntax tree can be clarified by parentheses `(...)`.
Otherwise, the parser reads prefix `a._` with highest operator precedence, then restriction `_ \ {_}`, then choice `+` and parallel `|` at equal level.
In case of ambiguity, it assumes parenthesization from the right.

{{< paragraph_heading "Equivalence queries." >}}
Queries for the behavioral equivalences between states are formulated in the code as well and started by clicking on the arrows that pop up in the gutter.
Output will appear right below the query in the editor.
The standard queries are:

- `@compare P1, P2` –
  Perform a spectroscopy on `P1` and `P2` with respect to the strong spectrum using the game of @sec-strong-spectroscopy.
  The output will have four items, relative to the strong spectrum.
  1. The strongest preorders to relate `P1` to `P2`;
  2. Cheapest formulas to distinguish `P1` from `P2` (and the smallest observation language they are part of);
  3. The list of finest equivalences to equate `P1` and `P2`.
  4. A visualization of the result on the whole spectrum.
     Moreover, there will be a link to a <https://edotor.net/>-visualization of the game graph used to obtain the result.
  The naming of notions in the output follows @tbl-notion-names.

- `@compareSilent P1, P2` – 
  Perform a spectroscopy on `P1` and `P2` with respect to the weak spectrum, treating silent steps along the lines of @sec-silent-step-spectroscopy.
  The output is analogous to `@compare`.
- `@check equivalence-name, P1, P2` –
  Checks for (mutual) preordering between `P1` and `P2` with respect to individual notion `equivalence-name`. 
  The name of the notion to be checked must be one of the ones in @tbl-notion-names.

```{=latex}
% fix to make the table float in spite of Pandoc's hardcoded longtable usage...
\begin{table*}[b!]
\parbox{15cm}{
```

| Strong variant       | Weak variants                      | Stable / stability-respecting variants   |
|:---------------------|:-----------------------------------|:-----------------------------------------|
| `enabledness`          | `weak-enabledness`                   |                                          |
| `trace`                | `weak-trace`                         |                                          |
| `failure`              | `weak-failure`                       | `stable-failure`                         |
| `revivals`             |                                    | `stable-revivals`                          |
| `readiness`            | `weak-readiness`                     | `stable-readiness`                         |
| `failure-trace`        |                                    | `stable-failure-trace`                     |
| `ready-trace`          |                                    | `stable-ready-trace`                       |
| `impossible-future`    | `weak-impossible-future`             |                                          |
| `possible-future`      | `weak-possible-future`               |                                          |
| `simulation`           | `weak-simulation`                    | `stable-simulation`                        |
| `ready-simulation`     | `weak-ready-simulation`              | `s-ready-simulation`                       |
| `2-nested-simulation`  | `2-nested-weak-simulation`           |                                          |
| `bisimulation`         | `contrasimulation`<br> `weak-bisimulation`<br> `delay-bisimulation`<br> `eta-bisimulation`<br> `branching-bisimulation` | `stable-bisimulation`<br> `sr-delay-bisimulation`<br> `sr-branching-bisimulation` |

: Names of supported notions in {{<equivio>}}. {#tbl-notion-names .column-body-outset}

``` {=latex}
}
\end{table*}
```

{{< paragraph_heading "Interacting with the output." >}}
Each output item can be clicked, which displays the preorders, equivalences, and distinctions that have been found between states in the transition system view.

States in the transition system may be dragged to change their position.
The layout information is persisted in the source, as described in the next list.

{{< paragraph_heading "Layout and preprocessing." >}}
The source can also contain layout information and prescribe some preprocessing for processes.

- `P(main)` –
  Highlight process `P` in transition system and prune other sub-processes (unless they are reached from `P`).
  Multiple processes may be declared to be `main`.
- `P(x=100, y=100)` –
  Annotate process `P` to be displayed at certain coordinates.
- `"0"(x=100, y=200)` –
  The annotations may also refer to sub processes
  The CCS expressions are wrapped in `"..."`.
  They must be verbatim the string representation the tool uses for the normalized process.
- `@preprocessing method1, method2...` –
  Apply preprocessing to the transition system after translation of the CCS term (that is, before presentation and queries happen).
  This will affect the whole transition system, but tries to preserve processes that have been marked as `main`.
  The order of processing steps can make a differnce.
  - `weakness_saturated` – Exchange transition relation to weak transitions, that is, there will be a transition whenever the original system allows $\stepweak\stepopt{\alpha}\stepweak$.
  - `tauloop_compressed_marked` – Collapse states on $\tau$-loops and mark them with a $\delta$.
    (This follows the thought of how to make equivalence queries divergence-respecting from @sec-extending-to-other-eqs.)
  - `bisim_minimized` – Merge states that are strongly bisimilar.
  - `srbb_minimized`  – Merge states that are stability-respecting branching-bisimilar (enforces `tau`-loops precisely on divergent states).
- `@comment "My comment"` –
  Any `@something`-tag without features can serve to add comments in the model.

### Application to Peterson's Mutual Exclusion {#sec-equivio-peterson}

Let us go through the whole process of using the tool once to tackle the example of Peterson's mutual exclusion protocol, which has already been previewed in @exm-peterson-mutex.
Thereby, we settle the question with respect to which equivalences the protocoll correctly implements the specification of mutual exclusion.
We follow the presentation of how to model this protocol in CCS from @ails2007reactiveSystems [Chapter 7], with action names chosen to align with @glabbeek2023mutexTimeouts.

We *specify* mutual exclusion as a system `Mx` of two alternating users `A` and `B` entering their critical section `ecA` / `ecB` and leaving `lcA` / `lcB` before the other may enter.
@ails2007reactiveSystems [Equation 7.1] suggest the following specification in CCS:

```ccs
Mx = ecA.lcA.Mx + ecB.lcB.Mx

@snip "----------storage--------"

ReadyAf = readyAf!ReadyAf + setReadyAf.ReadyAf + setReadyAt.ReadyAt
ReadyAt = readyAt!ReadyAt + setReadyAf.ReadyAf + setReadyAt.ReadyAt

ReadyBf = readyBf!ReadyBf + setReadyBf.ReadyBf + setReadyBt.ReadyBt
ReadyBt = readyBt!ReadyBt + setReadyBf.ReadyBf + setReadyBt.ReadyBt

TurnA = turnA!TurnA + setTurnA.TurnA + setTurnB.TurnB
TurnB = turnB!TurnB + setTurnA.TurnA + setTurnB.TurnB

@snip "----------individual processes----------"

A1 = setReadyAt!setTurnB!A2
A2 = readyBf.A3 + turnA.A3
A3 = ecA.lcA.setReadyAf!A1

B1 = setReadyBt!setTurnA!B2
B2 = readyAf.B3 + turnB.B3
B3 = ecB.lcB.setReadyBf!B1

@snip "----------system---------"

Pe = (A1 | B1 | TurnA | ReadyAf | ReadyBf)
    \ {readyAf, readyAt, setReadyAf, setReadyAt, readyBf, readyBt,
       setReadyBf, setReadyBt, turnA, turnB, setTurnA, setTurnB}

@snip "----------preprocessing----------"

Pe(main, x=900, y=340)
Mx(main, x=120, y=220)

@preprocessing srbb_minimized

@snip "----------equivalence-checks----------"

@check weak-trace, Pe, Mx
@check weak-bisimulation, Pe, Mx

@snip "----------spectroscopy queries----------"

@compareSilent Pe, Mx
@compareSilent Mx, Pe

@snip "----alternative spec with internal choice-----"

MxIC(main, x=120, y=0)
MxIC = tau.ecA.lcA.MxIC + tau.ecB.lcB.MxIC
@compareSilent Pe, MxIC

@snip "---------- below here, there's only layout information! ----------"

"(A1 | setTurnA!B2 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1102, y=548)
"(setTurnB!A2 | B1 | TurnA | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=681, y=398)
"(setTurnB!A2 | setTurnA!B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=949, y=636)
"(A1 | B2 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1199, y=767)
"(A1 | B3 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1452, y=961)
"(setTurnB!A2 | B3 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1310, y=1053)
"(A2 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=681, y=802)
"(A3 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=564, y=967)
"(lcA.setReadyAf!A1 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=441, y=1231)
"(lcA.setReadyAf!A1 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=548, y=1297)
"(setTurnB!A2 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=756, y=546)
"(A2 | B3 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1161, y=1116)
"(setTurnB!A2 | lcB.setReadyBf!B1 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1473, y=1257)
"(A1 | lcB.setReadyBf!B1 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1664, y=1102)
"(A2 | lcB.setReadyBf!B1 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1235, y=1348)
"(A2 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=790, y=1112)
"(A2 | B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1067, y=874)
"(setTurnB!A2 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1033, y=427)
"(A2 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=902, y=926)
"(setTurnB!A2 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=910, y=771)
"(A3 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=671, y=1078)
"(A3 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=829, y=1146)
"(lcA.setReadyAf!A1 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=785, y=1350)
"(setReadyAf!A1 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=701, y=1061)
"(A1 | B1 | TurnB | ReadyAf | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=806, y=794)
"(setReadyAf!A1 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=869, y=1064)
"(A1 | setTurnA!B2 | TurnB | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1016, y=535)
"(A1 | B1 | TurnA | ReadyAf | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=666, y=296)
"(A1 | setReadyBf!B1 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1542, y=816)
"(setTurnB!A2 | setReadyBf!B1 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1477, y=477)
"(A2 | setReadyBf!B1 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=644, y=761)
"(setReadyAf!A1 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1025, y=1064)

"lcA.Mx"(x=181, y=529)
"lcB.Mx"(x=433, y=290)
```

Can we come up with a process where two subprocesses run a protocol such that the overall system is somewhat equivalent to this specification?
@peterson1981mythsMutex proposes a protocoll that can be summarized by the following pesudocode:

```ruby
ready = {"A": false, "B": false}
turn  = "A"

def process(ownId, otherId):
  while true:                         # PC = 1
    ready[ownId] = true
    turn = otherId
    
    do # wait...                      # PC = 2
    until (ready[otherId] == false || turn == ownId)
      
    print "enter critical #{ownId}"   # PC = 3
    # critical section goes here.
    print "leave critical #{ownId}"
    ready[ownId] = false

process("A", otherId = "B") || process("B", otherId = "A")
```

The two processes share three variables:
`ready["A"]` expresses whether process `A` is ready to enter its criticl section; `ready["B"]` the same for `B`.
In `turn`, *both* processes try to write whose turn it is to enter, `A` or `B`.
Assuming sufficiently consistent memory, the protocol works because each process will only enter the critical section if no other process is waiting or if it has been yielded the turn (by the other process).
The critical scenario of both processes entering *symmetrically* is resolved because the race condition on the `turn`-write will flip a coin in such situations.

To express the shared-memory protocoll in the message-passign paradigm of CCS, we must model the storage as processes that run in parallel with the main model.
We do this as in @ails2007reactiveSystems:
In the following the process `ReadyAf` corresponds to `ready["A"] = false`, and `ReadyAt` to `ready["A"] = true`.
The current state can be either read (`readyAf` / `readyAt`) or written (`setReadyAf` / `setReadyAt`).

```ccs
@nolink
ReadyAf = readyAf!ReadyAf + setReadyAf.ReadyAf + setReadyAt.ReadyAt
ReadyAt = readyAt!ReadyAt + setReadyAf.ReadyAf + setReadyAt.ReadyAt

ReadyBf = readyBf!ReadyBf + setReadyBf.ReadyBf + setReadyBt.ReadyBt
ReadyBt = readyBt!ReadyBt + setReadyBf.ReadyBf + setReadyBt.ReadyBt

TurnA = turnA!TurnA + setTurnA.TurnA + setTurnB.TurnB
TurnB = turnB!TurnB + setTurnA.TurnA + setTurnB.TurnB
```

Each main process iterates through the phases 1, 2, and 3, corresponding to `PC = 1,2,3` in above pseudocode.
In 1, they set their `ready` and yield the `turn`;
in 2, they wait until they hear that the other's `ready` is false or that it is their `turn`;
in 3, they enter and leave their critical section, unset their `ready`, and return to step 1.

```ccs
@nolink
A1 = setReadyAt!setTurnB!A2
A2 = readyBf.A3 + turnA.A3
A3 = ecA.lcA.setReadyAf!A1

B1 = setReadyBt!setTurnA!B2
B2 = readyAf.B3 + turnB.B3
B3 = ecB.lcB.setReadyBf!B1
```

Peterson's protocol is the parallel composition of `A1`, `B1` and the storage, restricting communication with the memory:

```ccs
@nolink
Pe = (A1 | B1 | TurnA | ReadyAf | ReadyBf)
    \ {readyAf, readyAt, setReadyAf, setReadyAt, readyBf, readyBt,
       setReadyBf, setReadyBt, turnA, turnB, setTurnA, setTurnB}
```

If you enter above listings, you will notice that the transition system view is cluttered by cycles for the subprocesses.
These can be removed from the system output by declaring `Pe` and `Mx` as the `main` processes:

```ccs
@nolink
Pe(main, x=900, y=340)
Mx(main, x=120, y=220)
```

We can further clarify the transition graph, we can minimize it with respect to stability-respecting branching bisimilarity, resulting in the transition system of @fig-peterson-mutex:

```ccs
@nolink
@preprocessing srbb_minimized
```

We can now verify that `Pe` and `Mx` allow for the same weak traces, which, for instance, rules out bugs where both enter, `ecA` and `ecB`, after each other without the other leaving.

```ccs
@nolink
@check weak-trace, Pe, Mx
  > "States are equivalent."
```

But the processes are *not* weakly bisimilar, as tested by:

```ccs
@nolink
@check weak-bisimulation, Pe, Mx
  > "States are not preordered (nor equivalent)"
```

To get the full picture, we run a silent-step spectroscopy:

```ccs
@nolink
@compareSilent Pe, Mx
```

This yields to output:

```
• Preordered by:
    eta-simulation
    stable-simulation
• Left-right-distinguished by:
    ⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecA⟩⊤,¬⟨τ⟩⊤} (stable-failure)
    ⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤} (weak-failure)
• Equated by:
    weak-simulation
```

The weak failure `⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤}` can be understood to point out that `Pe` exceeds `Mx` in that
we can reach a state where `ecB` is impossible with no visible action.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … thinking about it, this behavior might be okay, for a mutual exclusion protocol, might it not?
Why should the outside observer need to be notified about the participating processes making up their minds?
So, let us try another specification of mutual exclusion where we leave it as an *iterated internal choice* of the system which participant may enter the critical section:

```ccs
@nolink
@comment "Internal-choice mutex"

MxIC(main, x=120, y=0)
MxIC = tau.ecA.lcA.MxIC + tau.ecB.lcB.MxIC
```

`Pe` aligns much better to the `MxIC`-specification!
`@compareSilent Pe, MxIC` returns:

```
• Preordered by:
    eta-simulation
    weak-ready-simulation
    s-ready-simulation
• Left-right-distinguished by:
    ⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤,¬⟨τ⟩⊤} (s-impossible-future)
    ⟨ϵ⟩⟨ecB⟩⟨ϵ⟩⟨lcB⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤} (delay-bisimulation)
    ⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤} (weak-impossible-future)
• Equated by:
    stable-readiness
    eta-simulation
    weak-ready-simulation
```

That means implementation `Pe` and internal choice specification `MxIC` cannot be distinguished from each other by a readiness observation (subsuming failures), neither in stable nor weak semantics.
Interestingly, in weak (that is, unstable) semantics the indistinguishability goes even further, up to weak ready simulation.

The main aspect that creates the differences between `Pe` and `MxIC` is that the implementation can decide that `B` will be the next entering the critical section next, even before `A` has left. 
In above output, this is mirrored by the impossible-future formula `⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤}`.

We can find this scenario already in the pseudo code.
It happens when both proceses are in `PC = 2` and `B` has set `turn = A`.
Then, `A` may enter its critical section but has to yield to `B` before it can re-enter.
So, this constitutes a proper difference between Peterson's protocol and a pure itereated internal choice.
But then again, one might say that it is fair of the process going first to leave the next round to the other waiting participant.
In the pure CCS view, however, we cannot adequately treat more general fairness considerations for Peterson's protocol, as @glabbeek2023mutexTimeouts explicates.

This is what the spectroscopy has taught us:
Peterson's mutual exclusion protocol is *more similar* to repeated internal choice (`MxIC`) than to the specifation `Mx` from @ails2007reactiveSystems.
However, the two are not bisimilar in any sense, since local progress from one iteration may influence the next.

### Program Structure

::: {#fig-equivio-flow fig-pos='t' fig-env="figure*"}
```tikz
\begin{tikzpicture}[auto,node distance=2cm,
  algstep/.style={minimum width=2.5cm, minimum height=1.2cm, draw=gray, rectangle,align=center,rounded corners}]
  \node[algstep] (Source) {Source};
  \node[algstep, below of=Source] (Syntax) {CCS system \\ \texttt{ccs.Syntax}};
  \node[algstep, right of=Syntax, node distance=6.1cm] (TS) {Transition system \\ \texttt{WeakTransitionSystem}};
  \node[algstep, below left of=TS, node distance=4cm] (SpectroGame) {Game + winning budgets \\ \texttt{StrongSpectroscopyGame}\\ or \texttt{WeakSpectroscopyGame}};
  \node[algstep, right of=TS, node distance=7cm] (Result) {Result \\ \texttt{SpectroscopyResult}};
  \node[algstep, below of=Result, node distance=1.5cm] (Notions) {Finest notions \\ \texttt{ObservationNotion[]}};
  \node[algstep, below of=Notions, node distance=1.5cm] (Formulas) {Distinguishing formulas \\ \texttt{HML.Formula[]}};
  \node[right of=Notions, node distance=5.5cm, align=center] (PriceYesNo) {Price okay? \\ $✔$ / $✗$};
  \node[right of=Formulas, node distance=5.5cm, align=center] (DistinctionYesNo) {Distinguishing? \\ $✔$ / $✗$};
  \node[algstep, above of=Result] (Output) {Visualization};

  \draw
    (Source) edge[->, swap] node {\texttt{ccs.Parser}} (Syntax)
    (Syntax) edge[->] node {\texttt{ccs.Interpreter}} (TS)
    (TS) |- ([yshift=1cm]SpectroGame.north) edge[->] node {\texttt{EnergyGame.populateGame}} (SpectroGame)
    (SpectroGame) edge node[->, swap] {\texttt{buildHMLWitness}} (Formulas)
    (Formulas) edge node[->, swap] {\texttt{hml.Interpreter}} (DistinctionYesNo);
\end{tikzpicture}
```

  <!-- \node[algstep, below of=TS, node distance=7.8cm] (BisimGame) {Bisimulation \\ game ${{\game}^{\system}_{\notionname{B}}}$};
  \node[algstep, right of=BisimGame, node distance=7cm] (WinningRegion) {Winning regions\\$\attackerwins^{{\game}^{\system}_{\notionname{B}}}$ and $\defenderwins^{{\game}^{\system}_{\notionname{B}}}$};
  \node[draw, diamond, above of=WinningRegion, node distance=2cm, minimum width=.8cm, minimum height=.8cm] (Decision) {};
  \node[algstep, above left of=Decision] (Relation) {Bisimulation \\ relation $\rel{R}_s$};
  \node[algstep, above right of=Decision] (Formula) {Distinguishing \\ formula $\varphi_s$};
  \node[algstep, above of=WinningRegion, node distance=7.8cm] (Output) {Yes / No};
  \node[above of=Relation, node distance=2.5cm] (Yes) {Certifiably yes $✔$};
  \node[above of=Formula, node distance=2.5cm] (No) {$✗$ Certifiably no};
  \path
    (TS) edge[->, swap] node {Def.~2.20} (BisimGame)
    (TS) edge[->, dashed] node {Bisimilar?} (Output)
    (BisimGame) edge[->] node {Alg.~2.1} (WinningRegion)
    (WinningRegion) edge[->, swap] node {$[p,q] \in \defenderwins^{{\game}^{\system}_{\notionname{B}}}$} (Decision)
    (Decision) edge[->] node {Yes: Thm.~2.2\vphantom{p}} (Relation)
    (Decision) edge[->, swap] node {No: Lem.~2.10\vphantom{p}} (Formula)
    (Relation) edge[->] node[align=right] {Check relation fulfills \\ bisimulation Def.~2.6\vphantom{p}} (Yes)
    (Formula) edge[->, swap] node[align=left] {Check distinction using \\ HML game Def~2.19 + Alg.~2.1\vphantom{p}} (No);
  \draw
    (Output.south) |- (Yes.east)
    (Output.south) |- (No.west); -->

Process flow in equiv.io
:::


- Parsing
  {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.ccs.Parser >}}
  `ccs.Syntax.Definition`
- Interpretation along @def-ccs-semantics ^[
    There is a minor semantical difference:
    The interpreter flattens process restriction in recursion.
    This leads to processes like `P = a.P \ {b}` having a finite process graph instead of an infinite one
    [cf. @ails2007reactiveSystems, Exercise 2.9].
  ]
  {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.ccs.Interpeter >}}
  `ts.WeakTransitionSystem`
    - Includes minimization if desired
- Spectroscopy
  - Either 
    {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.spectroscopy.StrongSpectroscopy >}}
  - Or 
    {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.spectroscopy.WeakSpectroscopy >}}
- Distinguishing formulas.
    - Pricing
        {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.hml.WeakObservationNotion >}}
        Check that formula price matches the one predicted by the game
    - Interpretation for validity
        {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.hml.Interpreter >}}
- `Spectroscopy.Result` from
    {{<code_link "shared/src/main/scala-2.12" io.equiv.eqfiddle.spectroscopy.Spectroscopy >}}

### Benchmarks

(TODO: Maybe)

## Student Implementations

There exist three other implementations of the equivalence spectroscopy algorithm by students of mine.
Each covers a different directions:
In @sec-spectro-invaders, we discuss *The Spectroscopy Invaders*, a computer-game version, which has an educational purpose.
@sec-spectroscopy-caal presents an extension to an existing educational tool, the Concurrency Workbench Aalborgh Edition.
@sec-gpu-equiv closes by reporting on *gpuequiv*, a performance-centric shader-based implementation using the modern WebGPU standard.

### Computer Game: *The Spectroscopy Invaders* {#sec-spectro-invaders}

Would it not be nice if one could *play* the spectroscopy game *as a game*?

@trzeciakiewicz2021ltbtBrowserGame develops the computer game “The Spectroscopy Invaders” where one plays the attacker in the spectroscopy game.
You can enjoy the game in the browser at <https://concurrency-theory.org/ltbt-game/>.

A play of the game corresponds to naming a universal attack strategy in the strong spectroscopy game of @def-strong-spectroscopy-game, or, equivalently, to constructing a distinguishing formula.
To reach maximal level scores, one has to play out a minimal formulas in the sense of our pricing.
Under the hood, the TypeScript implementation uses Bisping et al.'s [-@bjn2022decidingAllBehavioralEqs] algorithm to compute the minimal budgets,
although the game does not present the costs of moves to the player.

:::{#fig-spectro-invaders-screenshot-simple}

:::: {.content-visible when-format="html"}
{{< video https://github.com/Marii19/the-spectroscopy-invaders/raw/refs/heads/main/public/assets/videos/negation_move.mp4 >}}
::::
:::: {.content-visible unless-format="html"}
![](img/spectro-invaders-2.png){.lightbox}
::::

Screenshot of browser game “The Spectroscopy Invaders.”
:::

\noindent
@fig-spectro-invaders-screenshot-simple gives a screenshot of the first level of the “Failure” world.^[
  In the online version of this thesis, it is actually a screen capture by Trzeciakiewicz, illustrating negation moves in the game tutorial.
]
This level corresponds exactly to the classic @exm-ts if we match the orange transitions to $\tau$-steps, blue to $\literal{a}$, and yellow to $\literal{b}$.
The metaphor on top of the game mechanics is that the human-controlled hero (left) has to outmaneuver a group of elves (right) that might split up on non-deterministic transitions.

From @exm-spectroscopy-classic-ts, we know that the failure $\hmlobs{\tau}\hmlneg\hmlobs{\literal{a}}$ is a cheapest distinction of the left state from the right in this system.
In the game, we would use this distinction as follows:
First click on the state behind the left-most orange transition to *observe* it.
Then, click on the “negation” button ![](img/spectro-invaders-swap.png){width=1em} to swap sides of hero and elve.
Defeat the elve by moving along the right-most yellow edge.

The handling of conjunctions is a little more involved.

:::{#fig-spectro-invaders-screenshot}

![](img/spectro-invaders-1.png){.lightbox}

Second level of *Simulation* world.
:::

\noindent
@fig-spectro-invaders-screenshot shows the second level of the “Simulation” world.
In the level, the player's task is to distinguish
$\ccsprefix{\literal{white}}(\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange})$ (left) from
$\ccsprefix{\literal{white}}(\literal{red}\ccschoice\literal{orange}) \ccschoice \ccsprefix{\literal{white}}\ccsprefix{\literal{orange}}\literal{orange}$ (right).
The current game position occurs after the first white observation and corresponds to $\attackerpos{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \set{\literal{red}\ccschoice\literal{orange}, \ccsprefix{\literal{orange}}\literal{orange}}}$ in the strong spectroscopy game $\gamespectroscopy$,
as indicated by the hero figure on the left and the two elves on the right.

The player can click the “conjunct” button ![](img/spectro-invaders-conjunction.png){width=1em},
after which they have to explain how to win $\attackerpos[\land]{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \literal{red}\ccschoice\literal{orange}}$
and then $\attackerpos[\land]{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \ccsprefix{\literal{orange}}\literal{orange}}$.
In the split state, the player can first click through the yellow-arrow succesor states on the left to point out that the left elve cannot observe two yellow steps.
Then, they also have to name how to defeat the right elve, by taking the red transition.
Together, this strategy corresponds to the simulation formula $\hmlands\set{\hmlobs{\literal{yellow}}\hmlobs{\literal{yellow}}, \hmlobs{\literal{red}}}$.

The game is single-player, also in a theoretical sense:
There is no picking of conjunction answers by the defender.
Instead, the attacker has to name attacks for every right-hand state.
Due to nested conjunctions, the game positions thus actually are sets of $\attackerpos{p, Q}$ tuples.

@trzeciakiewicz2021ltbtBrowserGame limits the scope to (strong) trace, failure, possible-future, simulation, and bisimulation equivalences,
excluding notions like readiness, ready traces, and failure traces.
This allows for slightly simpler game rules, in particular, without revival moves.
This allows to nicely showcase the core mechanics of @sec-strong-spectroscopy with a stricter correspondence to procductions in the original HML of @def-hml.

### CAAL Extension {#sec-spectroscopy-caal}

Would it not be nice if one could use the equvialence spectroscopy in existing tools?

@ozegowski2023eqCAAL integrates the spectroscopy algorithm into *CAAL*, the “Concurrency Workbench Aalborg Edition” by @aaehlow2015caal.
@strassnickOzegowski2024weakCAAL also add the weak spectroscopy game and possibilities to play the spectroscopy game in the tool.
Their extended version of CAAL is live on <https://equivio.github.io/CAAL/>.

The original CAAL (on <https://caal.cs.aau.dk/>) covers the curriculum of Rective Sytems [@ails2007reactiveSystems], including CCS processes, HML formulas and equivalence games.

But CAAL originally only supports preorder/equivalence checking for six standard notions, namely for simulation, bisimulation, and traces, in their standard strong and weak variants.
Only simulation and bisimulation can be examined as games.

Straßnick and Ozegowski's extended CAAL version supports 13 strong and 21 weak notions.
Each of the notions can be decided individually, or in the context of a spectroscopy.
For the strong notions, the game graph can be explored interactively.
@fig-caal-screenshot shows the output of strong and weak spectroscopy on the classic @exm-ts, together with a generated distinguishing failure formula in the HML dialect of CAAL.

:::{#fig-caal-screenshot fig-pos="th"}

![](img/caal-extension.png){.lightbox}

Extended version of CAAL, performing a spectorscopy.
:::

For a usage guide, we refer to @strassnickOzegowski2024weakCAAL.

At some points, the fork unfortunately has to remain partial with respect to features.
For instance, the extension does not support distinguishing formulas for the weak spectroscopy because CAAL's HML dialect cannot easily be molded to support $\hmlsrbb$.

Still, the project shows that the spectroscopy approach is sufficiently simple and versatile to allow dozens of equivalence checkers to be integrated into existing tools within the limited scope of a student project.

### GPU Implementation: *gpuequiv* {#sec-gpu-equiv}

Would it not be nice if one could use modern hardware to perform spectroscopies as fast as possible?

@vogel2024energyGamesWebGPU implements the strong equivalence spectroscopy in *gpuequiv* using shaders in the WebGPU Shading Language @w3c2025wgsl.

Technically, this is superior to the other three implementations of this chapter, which can only exploit the single-threaded CPU model of JavaScript when running in the browser.

Histroically, the WebGL standard for browser graphics processing has lacked compute shaders.
This has made it difficult to access the computational power of graphics processing units from within web applications.
With WebGPU/WGSL [@w3c2025wgsl], times are changing.
@vogel2024energyGamesWebGPU makes this progress available to the spectroscopy approach.

Big parts of the game graph construction and the game solving are quite parallizable.
Therefore, for instance, a whole batch of game positions on a `todo`-list in @alg-deciding-energy-games can be processed simultaneously.
The details are explained in @vogel2024energyGamesWebGPU.

gpuequiv's control code surrounding the shader invocations is written in Rust that can be compiled to native code and to JavaScript.
Therefore, gpuequiv can be compiled for both kinds of targets:
Quick equivalence checking in the browser, and even quicker checking in a native application.
@vogel2024energyGamesWebGPU reports 10⨯ speed-ups.
However, the fast growth of game graphs remains a limiting factor as larger examples run into the size boundary of buffers to upload game moves.

At the time of writing, another Bachelor project is underway to add a frontend and support for the weak spectroscopy game to gpuequiv.

## Discussion

Preoder and equivalence checkers for more than 37 notions of strong and weak spectrum.

The survey by @gl2022eqChecking includes hundreds of tools to check bisimilarity and related equivalences and preorders.
Some also allow the construction of distinguishing formulas (or traces) to justify their output. 

Many tools support special variants, e.g. timed or probabilistic.

- FDR:

  https://cocotec.io/fdr/manual/cspm/prelude.html

  - strong bisim (as compression)
  - delay bisim (as compression)
  - weak bisim (as compression)

  - weak trace model (as refinement model)
  - stable failures (as refinement model)
  - failures-divergences (as refinement model)

- mCRL2
  - strong bisim
  - branching bisim
  - divergence-preserving branching bisim
  - weak bisim
  - divergence-preserving weak bisim
  - strong sim
  - strong ready sim
  - strong trace
  - weak trace
  - coupled sim
  - failures
  - stable failures
  - impossible futures
  - failures-divergence

- CADP
  - strong bisim
  - branching bisim
  - weak bisim (as observational equivalence)
  - tau*.a-equivalence / safety equivalence
  - strong trace
  - weak trace

- CAAL
  - strong bisim
  - weak bisim
  - strong sim
  - weak sim
  - strong traces
  - weak traces

other generalizing characterizations -> strong spectro @lange2014modelCheckingProcEqs; experience @stoecker2024HOcalculiEqs suggests that 20 states already demand several seconds in this approach.