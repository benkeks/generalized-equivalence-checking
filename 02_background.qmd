---
title: "Preliminaries: Communicating Systems and Games"
filters:
- teximg
---

{{< include style/macros.md >}}

TODO: Preliminaries....

## Behavior of Programs

### Labeled Transition Systems

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.
:::

{{<noindent>}} There is a canonical example used to discuss equivalences within transition systems.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#fig-henzinger .column-margin}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.
:::

::: {#exm-ts}
#### A Classic Example

  Consider the LTS given by the following graph:
  
  ```{mermaid}
  flowchart TD
    p0(P) -- τ --> pA(p<sub>a</sub>)
    p0 -- τ --> pB(p<sub>b</sub>)
    pA -- a --> pA0(p<sub>1</sub>)
    pB -- b --> pB0(p<sub>2</sub>)

    q0(Q) -- τ --> qAB(q<sub>ab</sub>)
    qAB -- a --> qA(q<sub>1</sub>)
    qAB -- b --> qB(q<sub>2</sub>)
  ```

  {{<noindent>}}
  The program described by the transitions from $\literal{P}$ choses non-deterministically during a $τ$-step between two options and then offers only either $\literal a$ *or* $\literal b$.
  The program $\literal{Q}$ on the other hand performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$ to the environment.
:::


{{<noindent>}}
There are two things one might wonder about @exm-ts:

1. Should one care about non-determinism in programs? Subsection [-@sec-ccs] shows how non-determinism arises naturally in concurrent programs.
2. Should one consider $\literal P$ and $\literal Q$ equivalent? This heavily depends. Section [-@sec-behavioral-eq] will introduce a notion of equivalence under which the two are equivalent and one under which they differ.

### Calculus of Communicating Systems {#sec-ccs}

To talk about programs in this thesis, we will use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS).

::: {#def-ccs}
#### Calculus of Communicating Systems

  Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions := \ccschannels \cup \set{ \coaction{\alpha} \mid \alpha \in \ccschannels } \cup \set{τ}$, are given by the following grammar:

  $$
  \begin{array}{cllr}
    P \grammardef
    & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“input action prefix”} \\
    & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“output action prefix”} \\
    & \ccsprefix{τ} P & &
        \text{“internal action”} \\
    & \ccsnull & &
        \text{“null process”} \\
    & X & \quad\text{with } X ∈ \ccsnames &
        \text{“recursion”} \\
    & P \ccschoice P & &
        \text{“choice”} \\
    & P \, \ccspar \, P & &
        \text{“parallel composition”} \\
    & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
        \text{“restriction”}
  \end{array}
  $$
  We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.
  The intuition is that an action $α$ represents receiving and $\coaction α$ expresses sending in communication.
  A pair of action and coaction can “react” in a communication situation and only become internal activity $τ$ in the view of the environment.

  Each sub-process tree must end in a $\ccsnull$-process or recursion.
  For brevity, we usually drop a final $\ccsnull$ when writing terms, e.g., just writing $\literal{ac}$ for $\ccsprefix{\literal{ac}} \ccsnull$.

  We place parenthesis, $(…)$, in terms where the syntax trees are otherwise ambiguous, but understand the choice operator $\ccschoice$ and the parallel operator $\ccspar$ to be associative.
:::

::: {#exm-ccs}
#### Concurrent Philosophers

  Following tradition, we will express our examples in terms of philosophers who need forks to eat spaghetti.^[
    Of course, you can just as well read the examples to be about computer programs that race for resources.]
  So, consider two philosophers $\literal{P_A}$ and $\literal{P_B}$ who want to grab a resource $\literal{fork}$ modeled as an action in order to eat where we express $\literal{P_A}$ eating with action $\literal{a}$ and $\literal{P_B}$ eating with $\literal{b}$.
  The philosopher processes read:

:::::: {.column-margin}
  ```{mermaid}
  flowchart TD
    p0(P<sub>A</sub>) -- fork --> pA(a.0)
    pA -- a --> 0(<strong>0</strong>)
  ```
::::::

  $$
  \begin{gathered}
    \literal{P_A} := \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull \\
    \literal{P_B} := \ccsprefix{\literal{fork}} \ccsprefix{\literal b} \ccsnull
  \end{gathered}
  $$
  An LTS representation of $\literal{P_A}$'s behavior can be seen in the margin.
  Process $\literal P$ captures the whole scenario where the two philosophers compete for the fork using communication:
  $$
    \literal P := ( \ccsprefix{\coaction{\literal{fork}}} \ccsnull \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  $$
  The restriction $… \ccsrestrict \set{\literal{fork}}$ expresses that the $\literal{fork}$-channel can only be used for communication within the system.

  As the $\coaction{\literal{fork}}$-action can be consumed by just one of the two philosophers, process $\literal P$ expresses exactly the program behavior seen in state $\literal P$ of @exm-ts.
:::

{{<noindent>}} The formal relationship between process terms and their LTS semantics is given by the following definition.

::: {#def-ccs-semantics}
#### CCS Semantics

Given an assignment of names to processes, $\ccsasg \colon \ccsnames → \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{α}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.
:::

{{< noindent >}} Feel free to go ahead an check that the transitions of @exm-ts indeed match those that @def-ccs-semantics prescribes for $\literal{P}$ of @exm-ccs!
(For readability, @exm-ts, has shorter state names, however.)
For instance, the transition $\literal P \step{τ} \literal{p_a}$ of @exm-ts would be justified as follows:

::: {.column-body-outset}
$$
\dfrac{
  \dfrac{
    \dfrac{
      \dfrac{
        \vphantom{\step{\coaction{\literal{fork}}}_\ccs}
      }{
        \coaction{\literal{fork}} \step{\coaction{\literal{fork}}}_\ccs \ccsnull
      }
      \quad
      \dfrac{
        \dfrac{
          \overline{
            \ccsprefix{\literal{fork}} \literal a
            \step{\literal{fork}}_\ccs
            \literal a
          }
          \qquad
          \ccsasg(\literal{P_A}) = \ccsprefix{\literal{fork}} \literal a
        }{
          \literal{P_A} \step{\literal{fork}}_\ccs \literal a
        }
      }{
        \literal{P_A} \ccspar \literal{P_B} \step{\literal{fork}}_\ccs \literal a \ccspar \literal{P_B}
      }
    }{
      \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B}
      \step{τ}_\ccs
      \ccsnull \ccspar \literal a \ccspar \literal{P_B}
    }
    \quad
    \begin{matrix}
      \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
      τ \notin A
    \end{matrix}
  }{
    ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
    \step{τ}_\ccs
    ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  }
  \quad
  \begin{matrix}
    \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
    \ccsasg(\literal P) = ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  \end{matrix}
}{
  \literal P \step{τ}_\ccs ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
}
$$
:::

{{< noindent >}} Non-determinism like in $\literal P$ of @exm-ts can be understood as a natural phenomenon in models with concurrency.
The model leaves unspecified which of two processes will consume an internal resource and, to the outsider, it is transparent which one took the resource until they communicate.
There are other ways how non-determinism plays a crucial role in models, for instance, as consequence of abstraction or parts that are left open in specifications.

The second process $\literal Q$ of @exm-ts can be understood as a deterministic sibling of $\literal P$.

::: {#exm-deterministic-phil}
#### Deterministic Philosophers

A process matching the transitions from $\literal Q$ in @exm-ts would be the following, where the philosophers take the fork as a team and then let the environment choose who of them eats:

$$
\literal Q := (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
$$

:::

## Behavioral Equivalences {#sec-behavioral-eq}

### Trace Equivalence

::: {#def-traces}
#### Traces

The set of traces of a process $\traces{p}$ is recursively defined as

- $\emptyword ∈ \traces{p}$,^[We denote the empty word by $\emptyword$.]
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.

:::

::: {#def-trace-eq}
#### Trace Equivalence

Two processes $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.

Processes are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.
:::

::: {#exm-phil-traces}

The traces for the processes of @exm-ts would be $\traces{\literal{P}} = \set{\emptyword, τ, τ\literal{a}, τ\literal{b}} = \traces{\literal Q}$. Consequently, $\literal P$ and $\literal Q$ are trace-equivalent, $\literal P \beq{T} \literal Q$.

As $\traces{\literal{p_a}} = \set{\emptyword, \literal{a}} ⊆ \set{\emptyword, \literal{a}, \literal{b}} = \traces{\literal{q_{ab}}}$, $\literal{p_a}$ is trace-preordered to $\literal{q_{ab}}$, $\literal{p_a} \bpreord{T} \literal{q_{ab}}$.
This ordering is strict, that is, $\literal{q_{ab}} \nbpreord{T} \literal{p_a}$, due to $\literal{b} ∈ \traces{\literal{q_{ab}}}$ but $\literal{b} \notin \traces{\literal{p_a}}$.
We could say that trace $\literal{b}$ constitutes a *difference* between $\literal{q_{ab}}$ and $\literal{p_a}$.
:::

### Simulation and Bisimulation

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.

:::

::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation-preorder, similarity and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.
:::


::: {#exm-phil-sim}

The following relations are simulations on the LTS of @exm-ts:

- the empty relation $\rel R_\varnothing := \varnothing$;
- the identity relation $\rel R_\mathrm{id} := \identity{\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}} = \set{(\literal P, \literal P),\allowbreak (\literal{p_a}, \literal{p_a}),\allowbreak (\literal{p_b}, \literal{p_b}), (\literal{p_1}, \literal{p_1}),\allowbreak (\literal{p_2}, \literal{p_2}), (\literal Q, \literal Q), (\literal{q_{ab}}, \literal{q_{ab}}), \allowbreak(\literal{q_1}, \literal{q_1}), (\literal{q_2}, \literal{q_2})}$;
- the universal relation between all final states $\rel R_\mathrm{fin} := \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}}²$,
- more generally, the relation from final states to all other states: $\rel R_\mathrm{up} := \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}} × \states$;
- a minimal simulation for $\literal P$ and $\literal Q$: $\rel R_\mathrm{sim} := \set{(\literal{P}, \literal{Q}), (\literal{p_a}, \literal{q_{ab}}), (\literal{p_b}, \literal{q_{ab}}), (\literal{p_1}, \literal{q_1}), (\literal{p_2}, \literal{q_2})}$;
- and the combination of the above $\rel R_\mathrm{max} := \rel R_\mathrm{sim} ∪ \rel R_\mathrm{id} ∪ \rel R_\mathrm{up}$.

{{<noindent>}} This shows, among other things, that $\literal P \bpreord{S} \literal Q$.

However, there is no simulation that preorders $\literal Q$ to $\literal P$, as there is no way to simulate the transition $\literal Q \step{\tau} \literal{q_{ab}}$ from $\literal P$ for lack of a successor that allows $\literal a$ *and* $\literal b$ as does $\literal{q_{ab}}$.

Thus, $\literal Q \nbpreord{S} \literal P$, and $\literal P \nbeq{S} \literal Q$. Moreover, there cannot be a symmetric simulation, $\literal P \nbeq{B} \literal Q$.
:::


## Observations as Modal Logic

::: {#def-observations}
#### Hennessy–Milner Logic

For a set of actions $\actions$, the *observations* (expressed as Hennessy–Milner logic $\hml$) follow the grammar:

$$
\begin{array}{cllr}
  \varphi \grammardef &
    \hmlobserve{α}\varphi & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    {}\grammaror \quad & \hmland{i}{I}\varphi_i & \quad\text{with index set } I & \text{“conjunction”} \\
    {}\grammaror \quad & \hmlneg \varphi & & \text{“negation”} \\
\end{array}
$$
Its semantics $\semantics{\cdot} \colon \hml \to \powerset{\states}$ is defined by:

```{=latex}
\begin{mathpar}
\inferrule*{
  p \step{α} p' \\ p' ∈ \semantics{\varphi}
}{
  p ∈ \semantics{\hmlobserve{α}\varphi}
}\and
\inferrule*{
  \forall i ∈ I \ldotp p ∈ \semantics{\varphi_i}
}{
  p ∈ \semantics{\hmland{i}{I}\varphi_i}
}\and
\inferrule*{
  p \notin \semantics{\varphi}
}{
  p ∈ \semantics{\hmlneg\varphi}
}

\end{mathpar}
```
:::

::: {#lem-hennessy-milner}

#### Hennessy–Milner Theorem

:::

<!-- We now use observations to give a denotational semantics for our $\ccs$ processes (overloading $\semantics{\cdot}$):

::: {#def-denotational}
#### Denotations

The denotational semantics of processes, $\semantics{\cdot} \colon \states \to \powerset{\hml}$, is defined:
$$\semantics{P} := \{ \varphi ∈ \hml \mid P ∈ \semantics{\varphi} \}.$$
::: -->



## Reachability Games

Definition Game

Small example game

Semantics as Game

