---
title: "Preliminaries: Communicating Systems and Games"
filters:
- teximg
---

{{< include style/macros.md >}}

TODO: Preliminaries....

## Behavior of Programs

### Labeled Transition Systems

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.
:::

{{<noindent>}} There is a canonical example used to discuss equivalences within transition systems.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#fig-henzinger .column-margin}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.
:::

::: {#exm-ts}
#### A Classic Example

  Consider the LTS given by the following graph:
  
  ```{mermaid}
  flowchart TD
    p0(P) -- τ --> pA(pA)
    p0 -- τ --> pB(pB)
    pA -- a --> pA0( )
    pB -- b --> pB0( )

    q0(Q) -- τ --> qAB(qAB)
    qAB -- a --> qA( )
    qAB -- b --> qB( )
  ```

  {{<noindent>}}
  The program described by the transitions from $\literal{P}$ choses non-deterministically during a $τ$-step between two options and then offers only either $\literal a$ *or* $\literal b$.
  The program $\literal{Q}$ on the other hand performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$ to the environment.
:::


{{<noindent>}}
There are two things one might wonder about @exm-ts:

1. Should one care about non-determinism in programs? Subsection [-@sec-ccs] shows how non-determinism arises naturally in concurrent programs.
2. Should one consider $\literal P$ and $\literal Q$ equivalent? This heavily depends. Section [-@sec-behavioral-eq] will introduce a notion of equivalence under which the two are equivalent and one under which they differ.

### Calculus of Communicating Systems {#sec-ccs}

To talk about programs in this thesis, we will use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS).

::: {#def-ccs}
#### Calculus of Communicating Systems

  Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions := \ccschannels \cup \set{ \coaction{\alpha} \mid \alpha \in \ccschannels } \cup \set{τ}$, are given by the following grammar:

  $$
  \begin{array}{cllr}
    P \grammardef
    & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“input action prefix”} \\
    & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“output action prefix”} \\
    & \ccsprefix{τ} P & &
        \text{“internal action”} \\
    & \ccsnull & &
        \text{“null process”} \\
    & X & \quad\text{with } X ∈ \ccsnames &
        \text{“recursion”} \\
    & P \ccschoice P & &
        \text{“choice”} \\
    & P \, \ccspar \, P & &
        \text{“parallel composition”} \\
    & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
        \text{“restriction”}
  \end{array}
  $$
  We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.
  The intuition is that an action $α$ represents receiving and $\coaction α$ expresses sending in communication.
  A pair of action and coaction can “react” in a communication situation and only become internal activity $τ$ in the view of the environment.

  Each sub-process tree must end in a $\ccsnull$-process or recursion.
  For brevity, we usually drop a final $\ccsnull$ when writing terms, e.g., just writing $\literal{ac}$ for $\ccsprefix{\literal{ac}} \ccsnull$.
:::

::: {#exm-ccs}
#### Concurrent Philosophers

  Following tradition, we will express our examples in terms of philosophers who need forks to eat spaghetti.^[
    Of course, you can just as well read the examples to be about computer programs that race for resources.]
  So, consider two philosophers $\literal{P_A}$ and $\literal{P_B}$ who want to grab a resource $\literal{fork}$ modeled as an action in order to eat where we express $\literal{P_A}$ eating with action $\literal{a}$ and $\literal{P_B}$ eating with $\literal{b}$.
  The philosopher processes read:

:::::: {.column-margin}
  ```{mermaid}
  flowchart TD
    p0(P_A) -- fork --> pA(a.0)
    pA -- a --> 0(0)
  ```
::::::

  $$
  \begin{gathered}
    \literal{P_A} := \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull \\
    \literal{P_B} := \ccsprefix{\literal{fork}} \ccsprefix{\literal b} \ccsnull
  \end{gathered}
  $$
  An LTS representation of $\literal{P_A}$'s behavior can be seen in the margin.
  Process $\literal P$ captures the whole scenario where the two philosophers compete for the fork using communication:
  $$
    \literal P := ( \ccsprefix{\coaction{\literal{fork}}} \ccsnull \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  $$
  The restriction $… \ccsrestrict \set{\literal{fork}}$ expresses that the $\literal{fork}$-channel can only be used for communication within the system.

  As the $\coaction{\literal{fork}}$-action can be consumed by just one of the two philosophers, process $\literal P$ expresses exactly the program behavior seen in state $\literal P$ of @exm-ts.
:::

{{<noindent>}} The formal relationship between process terms and their LTS semantics is given by the following definition.

::: {#def-ccs-semantics}
#### CCS Semantics

Given an assignment of names to processes, $\ccsasg \colon \ccsnames \to \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{α}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
:::

{{< noindent >}}A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.


## Behavioral Equivalences {#sec-behavioral-eq}

### Trace Equivalence

::: {#def-traces}
#### Traces

The set of traces of a process $\traces{p}$ is recursively defined as

- $() ∈ \traces{p}$,
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.

:::

::: {#def-trace-eq}
#### Trace Equivalence

Two processes $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.

Processes are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.
:::

### Simulation and Bisimulation

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.

:::


::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation-preorder, similarity and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.
:::


## Observations as Modal Logic

::: {#def-observations}
#### Hennessy–Milner Logic

For a set of actions $\actions$, the *observations* (expressed as Hennessy–Milner logic $\hml$) follow the grammar:

$$
\begin{array}{cllr}
  \varphi \grammardef &
    \hmlobserve{α}\varphi & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    {}\grammaror \quad & \hmland{i}{I}\varphi_i & \quad\text{with index set } I & \text{“conjunction”} \\
    {}\grammaror \quad & \hmlneg \varphi & & \text{“negation”} \\
\end{array}
$$
Its semantics $\semantics{\cdot} \colon \hml \to \powerset{\states}$ is defined by:

```{=latex}
\begin{mathpar}
\inferrule*{
  p \step{α} p' \\ p' ∈ \semantics{\varphi}
}{
  p ∈ \semantics{\hmlobserve{α}\varphi}
}\and
\inferrule*{
  \forall i ∈ I \ldotp p ∈ \semantics{\varphi_i}
}{
  p ∈ \semantics{\hmland{i}{I}\varphi_i}
}\and
\inferrule*{
  p \notin \semantics{\varphi}
}{
  p ∈ \semantics{\hmlneg\varphi}
}

\end{mathpar}
```
:::

::: {#lem-hennessy-milner}

#### Hennessy–Milner Theorem

:::

<!-- We now use observations to give a denotational semantics for our $\ccs$ processes (overloading $\semantics{\cdot}$):

::: {#def-denotational}
#### Denotations

The denotational semantics of processes, $\semantics{\cdot} \colon \states \to \powerset{\hml}$, is defined:
$$\semantics{P} := \{ \varphi ∈ \hml \mid P ∈ \semantics{\varphi} \}.$$
::: -->



## Reachability Games

Definition Game

Small example game

Semantics as Game

