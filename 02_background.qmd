# Preliminaries: Communicating Systems and Games {#sec-preliminaries}

{{< include style/macros.md >}}

There is a virtually infinite supply of formalisms to model programs and communicating systems.
They are accompanied by many notions for behavioral equivalence and refinement to relate or distinguish their models.

This chapter takes a tour into this field.
The tour is *agnostic* in building on the most basic and versatile formalism of *labeled transition systems* and on standard equivalences such as *trace equivalence* and *bisimilarity*.
The approach is also *opinionated* in focussing on Robin Milner's tradition of concurrency theory with a strong pull towards *game characterizations*.
The very core concepts are described in @sec-programs.

We will explore the trinity of relational, modal, and game-theoretic characterizations of behavioral equivalences.
@fig-equivalence-big-picture shows the scaffold of this section, instantiated to the classic notion of bisimilarity:

- @sec-behavioral-eq introduces (among other notions) bisimilarity through its *relational characterization* in terms of symmetric simulation relations.
- @sec-hml treats the dual connection of bisimilarity and the distinguishing powers of a *modal logic*, known as the *Hennessy--Milner theorem*.
- @sec-games shows that both, the relations to validate bisimilarity and the modal formulas to falsify it, appear as certificates of strategies in a *reachability game* where an attacker tries to states apart and a defender tries to prevent this.

::: {#fig-equivalence-big-picture fig-env="figure*"}
```tikz
\begin{tikzpicture}[auto,node distance=1.1cm,
  algstep/.style={minimum width=4.5cm, minimum height=1.2cm, draw=gray, rectangle,align=center,rounded corners}]
  \node[algstep, draw=TealBlue] (Bisim) {$p \beq{B} q$\\ $p$ and $q$ are bisimilar};
  \node[algstep, draw=TealBlue, right of=Bisim, node distance=7.5cm] (NotBisim) {$p \nbeq{B} q$ \\ $p$ and $q$ are not bisimilar};
  \node[below of=Bisim, text=TealBlue, rotate=270, label={[align=center]270:(Def~2.7)}] (Biff) {$:\!\!\iff$};
  \node[below of=NotBisim, gray, rotate=270] (NBiff) {$\iff$};
  \node[algstep, draw=TealBlue, below of=Biff] (Rel) {There is bisimulation $\rel{R}$\\such that $(p,q) \in \rel{R}$};
  \node[algstep, draw=Fuchsia, below of=NBiff] (Distinction) {Some $\varphi \in \hml$\\distinguishes $p$ from $q$};
  \node[below of=Rel, text=Peach, rotate=270, label={[align=right]270:Stirling's\\characterization}] (Siff) {$\iff$};
  \node[below of=Distinction, text=Peach, rotate=270, label=90:{Section 2.4.4}] (Giff) {$\iff$};
  \node[algstep, draw=Peach, below of=Siff] (DefenderWins) {Defender wins bisimulation\\game from $[p,q]$};
  \node[algstep, draw=Peach, below of=Giff] (AttackerWins) {Attacker wins bisimulation\\game from $[p,q]$};
  \path
    (Bisim) edge[draw=TealBlue] node[label=below:{(Def~2.7)}] {XOR} (NotBisim)
    (Rel) edge[draw=Fuchsia] node[label={[align=center]below:Hennessy--Milner\\theorem}] {XOR} (Distinction)
    (DefenderWins) edge[draw=Peach] node[label={[align=center]below:Determinacy\\of games}] {XOR} (AttackerWins);
  \node[text=TealBlue, right=2mm of NotBisim] (Sec22) {Section 2.2};
  \node[text=Fuchsia, right=2mm of Distinction] (Sec23) {Section 2.3};
  \node[text=Peach, right=2mm of AttackerWins] (Sec24) {Section 2.4};
\end{tikzpicture}
```

Core-correlations for bisimilarity between relational definition, modal distinguishability, and game.
:::

Readers who are familiar with the contents of @fig-equivalence-big-picture can mostly skim through this chapter of preliminaries.
The two core insights that this chapter intends to seed for coming chapters are:

::: {#nte-idea-games .callout-idea .callout-note}
#### It's all a game!
Equivalence games are a most versatile way to handle behavioral equivalences and obtain decision procedures.
The Hennessy--Milner theorem appears as a shadow of the determinacy of the bisimulation reachability game.
:::

::: {#nte-idea-modal-first .callout-idea .callout-note}
#### Modal first!

Modal characterizations allow a uniform handling of the hierarchy of equivalences.
Productions in grammars of potential distinguishing formulas translate to game rules for equivalence games.
:::

\noindent
Both points might seem non-standard to those who are more used to relational or denotational definitions of behavioral equivalences.
To provide them with a bridge, we will start with relational and denotational definitions---but once we have crossed the bridge, we will not go back.

## Behavior of Programs {#sec-programs}

Every computer scientist has some model in their head of what it is that their algorithms and programs are doing.
Usually these models are wrong,^[But some are useful, as the saying goes.] especially, once concurrency enters the picture.
The area of *formal methods* tries to make models sufficiently precise that one at least can say what went wrong.

### Labeled Transition Systems

Labeled transition systems are the standard formalism to discretely express the state space of programs, algorithms, and more.
One can think of them as nondeterministic finite automata where the finiteness constraint has been lifted.

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.{{<isb locale Labeled_Transition_Systems lts>}}

We write $\derivatives{p, α}$ for the set of derivative states $\set{p' \mid p \step α p'}$,
and $\initials{p}$ for the set of enabled actions $\set{α \mid \exists p' \ldotp p \step α p'}$.
:::

There is a canonical example used to discuss equivalences within transition systems, which we want to draw from.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#fig-henzinger .column-margin}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.
:::

::: {#exm-ts}
#### A Classic Example

Consider the transition system $\system_\literal{PQ} = (\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}, \set{\literal a, \literal b, τ}, \step{\cdot}_\literal{PQ})$ given by the following graph:

::::{#fig-ts-determinism fig-pos=H}
```tikz
\begin{tikzpicture}[->,auto,node distance=2cm]
  \node[state] (P){$\literal{P}$};
  \node[state, below left of=P] (PA){$\literal{p_a}$};
  \node[state, below right of=P] (PB){$\literal{p_b}$};
  \node[state, below of=PA] (P1){$\literal{p_1}$};
  \node[state, below of=PB] (P2){$\literal{p_2}$};
  \path
    (P)
      edge node[swap] {$\tau$} (PA)
      edge node {$\tau$} (PB)
    (PA)
      edge node {$\literal{a}\vphantom{\literal{b}}$} (P1)
    (PB)
      edge node {$\literal{b}$} (P2);

  \node[state, right=5cm of P] (Q){$\literal{Q}$};
  \node[state, below of=Q] (QAB){$\literal{q_{ab}}$};
  \node[state, below left of=QAB] (Q1){$\literal{q_1}$};
  \node[state, below right of=QAB] (Q2){$\literal{q_2}$};
  \path
    (Q)
      edge node {$\tau$} (QAB)
    (QAB)
      edge node[swap] {$\literal{a}\vphantom{\literal{b}}$} (Q1)
      edge node {$\literal{b}$} (Q2);
\end{tikzpicture}
```

Example system $\system_\literal{PQ}$.
::::

The program described by the transitions from $\literal{P}$ choses non-deterministically during a $τ$-step between two options and then offers only either $\literal a$ *or* $\literal b$.
The program $\literal{Q}$ on the other hand performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$ to the environment.
:::

There are two things one might wonder about @exm-ts:

1. Should one care about non-determinism in programs? Subsection [-@sec-ccs] shows how non-determinism arises naturally in concurrent programs.
2. Should one consider $\literal P$ and $\literal Q$ equivalent? This heavily depends. Section [-@sec-behavioral-eq] will introduce a notion of equivalence under which the two are equivalent and one under which they differ.

::: {#rem-tau}
#### A Note on $τ$

The action $τ$ (the greek letter “tau”) will in later chapters stand for *internal behavior* and receive special treatment in @sec-silent-transitions.
For the scope of this and the following three chapters, $τ$ is an action like every other.

Generally, this thesis aims to be consistent with notation and naming in surrounding literature.
<!--But people who have been exposed to fewer compiler classes and semantics literature often find all the greek letters daunting.-->
Where there are different options, we usually prefer the less-greek one.
<!--After all, everything this thesis is about is simple, in a sense.-->
Also, we will usually write literals and constant names in $\textsf{sans-serif}$ and variables in $\textit{italics}$.
For the internal action, the whole field has converged to $τ$ in italics, however---so, we will run with this.
:::

### Calculus of Communicating Systems {#sec-ccs}

To talk about programs in this thesis, we use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS), which---together with other great contributions---earned him the Turing award.
It is a tiny concurrent programming language that fits in your pocket, and can be properly described mathematically!

::: {#def-ccs}
#### Calculus of Communicating Systems

  Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions ≔ \ccschannels \cup \set{ \coaction{α} \mid α ∈ \ccschannels } \cup \set{τ}$, are given by the following grammar:

  $$
  \begin{array}{cllr}
    P \grammardef
    & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“input action prefix”} \\
    & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“output action prefix”} \\
    & \ccsprefix{τ} P & &
        \text{“internal action”} \\
    & \ccsnull & &
        \text{“null process”} \\
    & X & \quad\text{with } X ∈ \ccsnames &
        \text{“recursion”} \\
    & P \ccschoice P & &
        \text{“choice”} \\
    & P \, \ccspar \, P & &
        \text{“parallel composition”} \\
    & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
        \text{“restriction”}
  \end{array}
  $$
  We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.
  The intuition is that an action $α$ represents receiving and $\coaction α$ expresses sending in communication.
  A pair of action and coaction can “react” in a communication situation and only become internal activity $τ$ in the view of the environment.

  Each sub-process tree must end in a $\ccsnull$-process or recursion.
  For brevity, we usually drop a final $\ccsnull$ when writing terms, e.g., just writing $\literal{ac}$ for $\ccsprefix{\literal{ac}} \ccsnull$.

  We place parenthesis, $(…)$, in terms where the syntax trees are otherwise ambiguous, but understand the choice operator $\ccschoice$ and the parallel operator $\ccspar$ to be associative.
:::

::: {#exm-ccs}
#### Concurrent Philosophers

  Following tradition, we will express our examples in terms of philosophers who need forks to eat spaghetti.^[
    Of course, you can just as well read the examples to be about computer programs that race for resources.]
  So, consider two philosophers $\literal{P_A}$ and $\literal{P_B}$ who want to grab a resource $\literal{fork}$ modeled as an action in order to eat where we express $\literal{P_A}$ eating with action $\literal{a}$ and $\literal{P_B}$ eating with $\literal{b}$.
  The philosopher processes read:

:::::: {.column-margin}
```{mermaid}
%%| fig-width: .7
flowchart TD
  p0([P<sub>A</sub>]) -- fork --> pA([a.0])
  pA -- a --> 0([<strong>0</strong>])
```
::::::

  $$
  \begin{gathered}
    \literal{P_A} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull \\
    \literal{P_B} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal b} \ccsnull
  \end{gathered}
  $$
  An LTS representation of $\literal{P_A}$'s behavior can be seen in the margin.
  Process $\literal P$ captures the whole scenario where the two philosophers compete for the fork using communication:
  $$
    \literal P ≔ ( \ccsprefix{\coaction{\literal{fork}}} \ccsnull \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  $$
  The restriction $… \ccsrestrict \set{\literal{fork}}$ expresses that the $\literal{fork}$-channel can only be used for communication within the system.

  As the $\coaction{\literal{fork}}$-action can be consumed by just one of the two philosophers, process $\literal P$ expresses exactly the program behavior seen in state $\literal P$ of @exm-ts.
:::

The formal relationship between process terms and their LTS semantics is given by the following definition.

::: {#def-ccs-semantics}
#### CCS Semantics

Given an assignment of names to processes, $\ccsasg \colon \ccsnames → \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{α}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.
:::

So, when we were writing “$\literal{P_A} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull$” above, this was actually to claim that we are talking about a CCS system where the *process name* $\literal{P_A} \in \ccsnames$ and $\ccsasg(\literal{P_A}) ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull$.
By the semantics, this also leads to the existence of a *state* $\literal{P_A}$ in the CCS transition system, and usually that is the entity we are interested in when defining a process.

Feel free to go ahead an check that the transitions of @exm-ts indeed match those that @def-ccs-semantics prescribes for $\literal{P}$ of @exm-ccs!
(For readability, @exm-ts, has shorter state names, however.)
For instance, the transition $\literal P \step{τ} \literal{p_a}$ of @exm-ts would be justified as follows:

::: {.column-body-outset}
$$
\dfrac{
  \dfrac{
    \dfrac{
      \dfrac{
        \vphantom{\step{\coaction{\literal{fork}}}_\ccs}
      }{
        \coaction{\literal{fork}} \step{\coaction{\literal{fork}}}_\ccs \ccsnull
      }
      \quad
      \dfrac{
        \dfrac{
          \overline{
            \ccsprefix{\literal{fork}} \literal a
            \step{\literal{fork}}_\ccs
            \literal a
          }
          \qquad
          \ccsasg(\literal{P_A}) = \ccsprefix{\literal{fork}} \literal a
        }{
          \literal{P_A} \step{\literal{fork}}_\ccs \literal a
        }
      }{
        \literal{P_A} \ccspar \literal{P_B} \step{\literal{fork}}_\ccs \literal a \ccspar \literal{P_B}
      }
    }{
      \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B}
      \step{τ}_\ccs
      \ccsnull \ccspar \literal a \ccspar \literal{P_B}
    }
    \quad
    \begin{matrix}
      \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
      τ \notin \set{\literal{fork}}
    \end{matrix}
  }{
    ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
    \step{τ}_\ccs
    ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  }
  \quad
  \begin{matrix}
    \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
    \ccsasg(\literal P) = ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  \end{matrix}
}{
  \literal P \step{τ}_\ccs ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
}
$$
:::

{{< noindent >}} Non-determinism like in $\literal P$ of @exm-ts can be understood as a natural phenomenon in models with concurrency.
The model leaves unspecified which of two processes will consume an internal resource and, to the outsider, it is transparent which one took the resource until they communicate.
There are other ways how non-determinism plays a crucial role in models, for instance, as consequence of abstraction or parts that are left open in specifications.

The second process $\literal Q$ of @exm-ts can be understood as a deterministic sibling of $\literal P$.

::: {#exm-deterministic-phil}
#### Deterministic Philosophers

A process matching the transitions from $\literal Q$ in @exm-ts would be the following, where the philosophers take the fork as a team and then let the environment choose who of them eats:

$$
\literal Q ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
$$
:::

But are $\literal{P}$ and $\literal{Q}$ equivalent?

## Behavioral Equivalences {#sec-behavioral-eq}

A behavioral equivalence formally defines when to consider two processes (or states, or programs) as *equivalent*.
Clearly, there might be different ways of choosing such a notion of equivalence.
Also, sometimes we are interested in a behavioral *preorder*, for instance, as a way of saying that a program does “less than” what some specification allows.

This section will quickly introduce the most common representatives of behavioral equivalences:
Trace equivalence (and preorder), simulation equivalence (and preorder), and bisimilarity.
We will then observe that the notions themselves can be compared in a hierarchy of equivalences.

### Trace Equivalence

Every computer science curriculum features automata and their languages sometime at the beginning.
Accordingly, comparing two programs in terms of the sequences of input/ouput events they might expose, referred to as their *traces*, is a natural starting point to talk about behavioral equivalences.

::: {#def-traces}
#### Traces

The set of traces of a state $\traces{p}$ is recursively defined as

- $\emptyword ∈ \traces{p}$,^[We denote the empty word by $\emptyword$.]
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.{{<isb abbreviation Labeled_Transition_Systems lts.traces>}}
:::

::: {#def-trace-eq}
#### Trace Equivalence

Two states $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.{{<isb abbreviation Strong_Equivalences lts.trace_equivalent>}}

States are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.{{<isb definition Strong_Equivalences lts.trace_preordered>}}
:::

::: {#exm-phil-traces}
The traces for the processes of @exm-ts would be $\traces{\literal{P}} = \set{\emptyword, τ, τ\literal{a}, τ\literal{b}} = \traces{\literal Q}$. Consequently, $\literal P$ and $\literal Q$ are trace-equivalent, $\literal P \beq{T} \literal Q$.

As $\traces{\literal{p_a}} = \set{\emptyword, \literal{a}} ⊆ \set{\emptyword, \literal{a}, \literal{b}} = \traces{\literal{q_{ab}}}$, $\literal{p_a}$ is trace-preordered to $\literal{q_{ab}}$, $\literal{p_a} \bpreord{T} \literal{q_{ab}}$.
This ordering is strict, that is, $\literal{q_{ab}} \nbpreord{T} \literal{p_a}$, due to $\literal{b} ∈ \traces{\literal{q_{ab}}}$ but $\literal{b} \notin \traces{\literal{p_a}}$.
We could say that trace $\literal{b}$ constitutes a *difference* between $\literal{q_{ab}}$ and $\literal{p_a}$.
:::

::: {#prp-trace-eq-rel}
The trace preorder $\bpreord{T}$ is indeed a preorder (i.e., transitive and reflexive){{<isb lemma Strong_Equivalences lts.trace_preorder_transitive>}} and trace equivalence $\beq{T}$ is indeed an equivalence relation (i.e., transitive, reflexive, and moreover symmetric).{{<isb lemma Strong_Equivalences lts.trace_equivalence_equiv>}}
:::
<!-- ::: proof
The properties carry over directly from $⊆$ and $=$ on sets of $\traces{\cdot}$.
:::-->

Trace equivalence and preorder assign programs straightforward *denotational semantics*:
The sets of traces they might expose.
For many languages, these mathematical objects can be constructed directly from the expressions of the language.
With the idea that the program text “denotes” its possible executions, the set of traces is called a “denotation” in this context.
CCS, as we use it, follows another approach to semantics, namely the one of “operational semantics,” where the meaning of a program is in how it might execute.

There are several reasons why computer scientist did content semselves with trace equivalence when studying interactive systems.
The core argument is that, in this context, one usually does not want to consider processes like $\literal{P}$ and $\literal{Q}$ to be equivalent:
The two might interact differently with an environment.
For instance, assume there is a user that wants to communicate $(\dots \ccspar \ccsprefix{\literal{a}}\ccsprefix{\literal{success}} \ccsnull) \ccsrestrict \set{\literal{a}}$.
In interactions with $\literal{Q}$, they will always reach $\literal{success}$;
with $\literal{P}$, there is a possibility of ending up deadlocked in parallel with $\literal{p_b}$, never achieving success.

### Simulation and Bisimulation

The other big approach to behavioral equivalence of programs is the one of relating parts of their state spaces to one-another.
The idea here is to identify which states of one program can be used to *simulate* the behavior of the another.

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.{{<isb definition Strong_Equivalences lts.simulation>}}
:::

::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation preorder, simulation equivalence and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.{{<isb definition Strong_Equivalences lts.simulated_by>}}
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.{{<isb abbreviation Strong_Equivalences lts.similar>}}
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.{{<isb definition Strong_Equivalences lts.bisimilar>}}
:::

We also call a symmetric simulation *bisimulation* for short.^[
  Other authors use a weaker definition, namely, that $\rel R$ is a bisimulation if $\rel{R}$ and $\inverse{\rel{R}}$ are simulations.
  Both definitions lead to the characterization of the same notion of bisimilarity.
]
Canceled symbols of relations refer to their negations, for instance, $p \nbeq{S} q$ iff there is *no* simulation $\rel R$ with $(p, q) ∈ \rel R$.

::: {#exm-phil-sim}
The following relations are simulations on the LTS of @exm-ts:

- the empty relation $\rel R_\varnothing ≔ \varnothing$;
- the identity relation $\rel R_\mathrm{id} ≔ \identity{\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}} = \set{(\literal P, \literal P),\allowbreak (\literal{p_a}, \literal{p_a}),\allowbreak (\literal{p_b}, \literal{p_b}), (\literal{p_1}, \literal{p_1}),\allowbreak (\literal{p_2}, \literal{p_2}), (\literal Q, \literal Q), (\literal{q_{ab}}, \literal{q_{ab}}), \allowbreak(\literal{q_1}, \literal{q_1}), (\literal{q_2}, \literal{q_2})}$;
- the universal relation between all final states $\rel R_\mathrm{fin} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}}²$,
- more generally, the relation from final states to all other states: $\rel R_\mathrm{up} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}} × \states$;
- a minimal simulation for $\literal P$ and $\literal Q$: $\rel R_\literal{PQ} ≔ \set{(\literal{P}, \literal{Q}), (\literal{p_a}, \literal{q_{ab}}), (\literal{p_b}, \literal{q_{ab}}), (\literal{p_1}, \literal{q_1}), (\literal{p_2}, \literal{q_2})}$;
- and the combination of the above $\rel R_\mathrm{max} ≔ \rel R_\mathrm{sim} ∪ \rel R_\mathrm{id} ∪ \rel R_\mathrm{up}$.

The simulation $\rel R_\literal{PQ}$ shows that $\literal P \bpreord{S} \literal Q$.

However, there is no simulation that preorders $\literal Q$ to $\literal P$, as there is no way to simulate the transition $\literal Q \step{τ} \literal{q_{ab}}$ from $\literal P$ for lack of a successor that allows $\literal a$ *and* $\literal b$ as does $\literal{q_{ab}}$.
(In @sec-hml, we will discuss how to capture such differences more formally.)

Thus, $\literal Q \nbpreord{S} \literal P$, and $\literal P \nbeq{S} \literal Q$. Moreover, there cannot be a symmetric simulation, $\literal P \nbeq{B} \literal Q$.
:::

::: {#prp-sim-eq-rel}
The simulation preorder $\bpreord{S}$ is indeed a preorder{{<isb lemma Strong_Equivalences lts.simulation_preorder_transitive>}}, and $\beq{S}$ and $\beq{B}$ are equivalences.{{<isb lemma Strong_Equivalences lts.bisimilarity_equiv>}}
:::
<!-- Too trivial.
::: proof
1. Reflexivity of $\bpreord{S}$, $\beq{S}$ and $\beq{B}$:<br> $\identity{\states}$ is a (symmetric) simulation on each transition system.
2. Transitivity of $\bpreord{S}$:<br>
  If $\rel R_1$ and $\rel R_2$ are simulations, then the composition $\rel R_1 \rel R_2$ too is a simulation.
  This also establishes transitivity of $\beq{S}$.
  Moreover, that simulation $\rel R_1$ and $\rel R_2$ imply the composition $\rel R_1 \cup \rel R_2$ to be a simulation, allows to combine symmetric simulations to prove transitivity of $\beq{B}$.
3. Symmetry of $\beq{S}:$ By definition.
4. Symmetry of $\beq{B}$:<br>
  $p \beq{B} q$ implies there is a symmetric simulation $\rel R$ with $(p,q) ∈ \rel R$.
  As $\rel R = \inverse{\rel R}$, this implies $(q,p) ∈ \rel R$ and thus $q \beq{B} p$.
  \qedhere
:::
-->

### The Hierarchy of Equivalences {#sec-hierarchy-equivalences}

Bisimilarity, similarity and trace equivalence form a small hierarchy of equivalences in the sense that they imply one-another in one direction, but not in the other.
Let us quickly make this formal:

:::: {#fig-core-hierarchy .column-margin}
```{mermaid}
%%| fig-width: 1.5
flowchart TD
  GI[Graph Isomorphism] -.-> B[Bisimilarity] --> S[Similarity] --> T[Trace Equivalence]
  style GI stroke-dasharray: 3 3
```

  Core hierarchy of equivalences.
::::

::: {#lem-bisim-bisim}
The relation $\beq{B}$ is itself a symmetric simulation.{{<isb lemma Strong_Equivalences lts.bisim_bisim>}}
:::

::: {#cor-bisim-impl-sim}
If $p \beq{B} q$, then $p \beq{S} q$.{{<isb lemma Strong_Equivalences lts.bisim_bisim>}}
:::

::: {#lem-sim-impl-traces}
If $p \bpreord{S} q$, then $p \bpreord{T} q$.{{<isb lemma Strong_Equivalences lts.sim_implies_trace_preord>}}
(Consequently, $p \beq{S} q$ also implies $p \beq{T} q$.{{<isb lemma Strong_Equivalences lts.sim_eq_implies_trace_eq>}})
:::

{{<noindent>}} We also have seen with example @exm-phil-sim that this hierarchy is strict between trace and simulation preorder in the sense that there exist $p,q$ with $p \bpreord{T} q$ but not $p \bpreord{S} q$.
The hierarchy also is strict between similarity and bisimilarity as the following example shows.

::: {#exm-bisim-sim}
#### Trolled philosophers

Let us extend $\literal{Q}$ of @exm-deterministic-phil to include a troll process that might consume the $\literal{fork}$ and then do nothing:
$$
\literal {T} ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork} \ccspar \literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
$$
This adds another deadlock state to the transition system, seen in @fig-bisim-sim-ts.

:::: {#fig-bisim-sim-ts .column-margin}
```{mermaid}
%%| fig-width: 1.5
flowchart TD
  q0([T]) -- τ --> qAB([q<sub>ab</sub>])
  qAB -- a --> qA([q<sub>1</sub>])
  qAB -- b --> qB([q<sub>2</sub>])
  q0 -- τ --> qT([q<sub>3</sub>])
```
Example with new deadlock $\literal{q_3}$.
::::

To similarity, this change is invisible, that is $\literal Q \beq{S} \literal{T}$.
(Reason: The relation $\set{(\literal Q, \literal{T}), (\literal{T}, \literal{Q})} \cup \identity{\set{ \literal{q_{ab}}, \literal{q_1}, \literal{q_2}, \literal{q_3}}}$ is a simulation.)

However, to bisimilarity, $\literal{T} \step{τ} \literal{q_3}$ constitutes a difference.
There cannot be a symmetric simulation handling this transition as $\literal{Q}$ has no deadlocked successors.
Thus $\literal Q \nbeq{B} \literal{T}$.
:::

The equivalences we have been discussed so far could also be understood as abstractions of an even finer equivalence, namely graph isomorphism:

::: {#def-graph-isomorphism}
#### Graph Isomorphism

A bijective function $f \colon \states \to \states$ is called a *graph isomorphism* on a transition system if, for all $p,p', α$, the transition $p \step{α} p'$ exists if and only if the transition $f(p) \step{α} f(p')$ exists.{{<isb definition Strong_Equivalences lts.isomorphism>}}

Two states $p$ and $q$ are considered *graph-isomorphism-equivalent*, $p \beq{ISO} q$, iff there is a graph isomorphism $f$ with $f(p) = q$.{{<isb definition Strong_Equivalences lts.is_isomorphic_to>}}
:::

:::: {#exm-graph-isomorphism}
Consider the transition system in @fig-iso-ts. $\literal{p_{even}} \beq{ISO} \literal{p_{odd}}$ because $f ≔ \set{\literal{p_{even}} \mapsto \literal{p_{odd}}, \literal{p_{odd}} \mapsto \literal{p_{even}}}$ is a graph isomorphism.

::: {#fig-iso-ts .column-margin}
```{mermaid}
%%| fig-width: 1
flowchart TD
  pEven([p<sub>even</sub>]) -- τ --> pOdd([p<sub>odd</sub>]) -- τ --> pEven
```

Transition system with an isomorphic cycle.
:::
::::

::: {#lem-iso-impl-bisim}
The relation $\beq{ISO}$ is itself a symmetric simulation and thus $p \beq{ISO} q$ implies $p \beq{B} q$.{{<isb lemma Strong_Equivalences lts.iso_implies_bisim>}}
:::

\noindent
Once again, the hierarchy is strict because of bisimilarity being less restricted in the matching of equivalent states.

::: {#exm-iso-vs-bisim}
Consider the processes $\literal{P_1} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $\literal{P_2} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$.
$\literal{P_1}$ can transition to $(\ccsnull \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$, while $\literal{P_2}$ has two options, namely $(\ccsnull \ccspar \ccsnull \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $(\ccsnull \ccspar \literal{fork} \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$. All three reachable processes are deadlocks and thus isomorphic.
But $\literal{P_1} \nbeq{ISO} \literal{P_2}$ because no bijection can connect the one successor of $\literal{P_1}$ and the two of $\literal{P_2}$.
However, $\literal{P_1} \beq{B} \literal{P_2}$, as bisimilarity is more relaxed.
:::

### Congruences

One of the prime quality criteria for behavioral equivalences is whether they form *congruences* with respect to fitting semantics or other important transformations.
A congruence relates mathematical objects that can stand in for one-another in certain contexts, which, for instance, allows term rewriting.
The concept is closely linked to another core notion of mathematics: monotonicity.

::: {#def-monotonic}
#### Monotonicity and Congruence

An $n$-ary function $f \colon B_1 \times \dots \times B_n \to C$ is called *monotonic* with respect to a family of partial orders $(B_k, \leq_k)$ and $(C, \leq)$ iff, for all $b \in B_1 \times \dots \times B_n$ and $b' \in B_1 \times \dots \times B_n$, it is the case that $b_k \leq b'_k$ for all $k \leq n$ implies that $f(b) \leq f(b')$.
We will usually encounter settings where all components use the same order $(B_1, \leq_1) = \cdots = (B_n, \leq_n) = (C, \leq)$

The relation $\leq$ is then referred to as a *precongruence* for $f$.
If $\leq$ moreover is symmetric (and thus an equivalence relation), then $\leq$ is called a *congruence* for $f$.
:::

::: {#exm-congruence-oddity}
#### Parity as Congruence
As a standard example for a congruence, consider the equivalence relation of equally odd numbers
$${\sim_\literal{odd}} := \set{(m,n) \in \nats \times \nats \mid m \bmod 2 = n \bmod 2}.$$
For instance, $1 \sim_\literal{odd} 3$ and $0 \sim_\literal{odd} 42$, but not $42 \sim_\literal{odd} 23$.

$\sim_\literal{odd}$ is a congruence for addition and multiplication.
For instance, the sum of two odd numbers will always be even; the product of two odd numbers, will always be odd.

But $\sim_\literal{odd}$ is no congruence for integer division.
For instance, $2 \sim_\literal{odd} 4$, but $2 / 2 = 1 \not\sim_\literal{odd} 2 = 4 / 2$.
:::

::: {#lem-ccs-congruences}
Trace equivalence and bisimilarity on the CCS transition system (@def-ccs-semantics)
are congruences for the operators of CCS (@def-ccs).
:::
:::proof
This is a well-established fact.
TODO: Citation!

As an example, let us prove the congruence property for choice, $\ccschoice$, on bisimilarity, $\beq{B}$.
For any CCS context, we assume $P \beq{B} R$ and $Q \beq{B} T$.
We have to show that $P \ccschoice Q \beq{B} R \ccschoice T$,
that is due to symmetry, that for any $\alpha$ with $P \ccschoice Q \step{\alpha}_\ccs \mathit{PQ}'$ there is $\mathit{RT}'$ such that $R \ccschoice T \step{\alpha}_\ccs \mathit{RT}'$ and $\mathit{PQ}' \beq{B} \mathit{RT}'$.
By the semantics of CCS, the first step must be either due to $P \step{\alpha}_\ccs \mathit{PQ}'$ or, analogously, $Q \step{\alpha}_\ccs \mathit{PQ}'$.
Without loss of generality, we only consider $P \step{\alpha}_\ccs \mathit{PQ}'$.
Due to $P \beq{B} R$, this step implies some $R'$ with $R \step{\alpha}_\ccs R'$ and $\mathit{PQ}' \beq{B} R'$.
As $R \ccschoice T \step{\alpha}_\ccs R'$, we can take this $R'$ to prove our goal.
:::

The nice thing about congruences is that we can use them to *calculate with terms*, as is common in mathematics.

Graph isomorphism fails to be a congruence for CCS operators.
For instance, consider $\ccsprefix{\literal{a}} (\ccsnull \ccspar \ccsnull) \beq{ISO} \ccsprefix{\literal{a}} \ccsnull$, but $\ccsprefix{\literal{a}} \ccsnull + \ccsprefix{\literal{a}} (\ccsnull \ccspar \ccsnull) \nbeq{ISO} \ccsprefix{\literal{a}}\ccsnull + \ccsprefix{\literal{a}}\ccsnull \beq{ISO} \ccsprefix{\literal{a}} \ccsnull$.


<!-- too complicated!

We could establish equivalences like the following:

$$
\begin{array}{rrcl}
(1) & \ccsprefix{\coaction{a}} P \ccspar \ccsprefix{a} Q & \beq{B}
    & \ccsprefix{\coaction{a}} (P \ccspar \ccsprefix{a} Q) \ccschoice \ccsprefix{a} (\ccsprefix{\coaction{a}} P \ccspar Q) \ccschoice \ccsprefix{\tau} (P \ccspar Q) \\
(2) & (\ccsprefix{a} P \ccschoice \ccsprefix{b} Q) \ccsrestrict A & \beq{B} & \ccsprefix{a} P \ccsrestrict A \ccschoice \ccsprefix{b}Q \ccsrestrict A \\
(3) & (\ccsprefix{a} P) \ccsrestrict \set{a} & \beq{B} & 0 \\
(4) & \ccsnull \ccschoice P & \beq{B} & P \\
(5) & \ccsnull \ccspar P & \beq{B} & P
\end{array}
$$

$$
\begin{array}{rcl}
&  & (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork} \ccspar \literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}} \\
& \beq{B} &
  ( \ccsprefix{\tau} (\ccsnull \ccspar \ccsnull \ccspar \ccsprefix{\literal{fork}} (\literal{a} \ccschoice \literal{b})) \ccschoice \ccsprefix{\tau} ( \ccsnull \ccspar \literal{fork} \ccspar \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}
\end{array}
$$

-->

### Quotient Systems and Minimizations

One of the prime applications of behavioral equivalences is to battle the *state space explosion problem*:
The transition systems of parallel processes quickly grow in size, usually exponentially with regard to the number of communication participants.
But many of the states tend to be equivalent in behavior, and can be treated *as one* with their equals.
This *minimization* hugely increases the size of models that can be handled in algorithms.

::: {#exm-bisim-minimization}
#### Trolled philosophers, minimized

In @exm-bisim-sim of “trolled philosophers,” all terminal states are bisimilar, $\literal{q_1} \beq{B} \literal{q_2} \beq{B} \literal{q_3}$.
We can thus merge them into one state $\literal{q_{123}^m}$ as depicted in @fig-bisim-min-ts, without affecting the behavioral properties of the other states with respect to bisimilarity, that is, $\literal{q_{ab}} \beq{B} \literal{q_{ab}^m}$ and $\literal{T} \beq{B} \literal{T^m}$.

:::: {#fig-bisim-min-ts .column-margin}
```{mermaid}
%%| fig-width: 1.5
flowchart TD
  q0([T<sup>m</sup>]) -- τ --> qAB([q<sub>ab</sub><sup>m</sup>])
  qAB -- a --> qABT([q<sub>123</sub><sup>m</sup>])
  qAB -- b --> qABT
  q0 -- τ --> qABT
```
Minimized version of @fig-bisim-sim-ts.
::::

:::

::: {#def-quotient-ts}
Given an equivalence relation $\sim$ on states, and a transition system $\system=(\states,\actions,\step{})$,
each *equivalence class* for $p \in \states$ is defined $\eqclass{p}_{\sim} \defeq \set{p' \in \states \mid p \sim p'}$.

The *quotient system* is defined as $\quotient{\system}{\sim} \defeq (\quotient{\states}{\sim}, \actions, \step{}_{\sim})$, where $\quotient{\states}{\sim}$ is the set of equivalence classes $\set{ \eqclass{p} \mid p \in \states}$, and
$$P \step{\alpha}_\sim P' \text{ iff there are $p \in P$ and $p' \in P'$ such that $p \step{\alpha} p'$.}$$
:::

::: {#prp-bisim-minimization}
On the combined system of $\system$ and $\quotient{\system}{\beq{B}^{\system}}$, states and their derived class are bisimilar, $p \beq{B} \eqclass{p}_{\beq{B}^{\system}}$.
:::

The same reasoning does not apply to graph isomorphism:
In @exm-bisim-minimization, the terminal states might be graph-isomorphic, but merging them changes the number of states and thus prevents isomorphism between $\literal{T}$ and $\literal{T^m}$.

Together with the issue of congruence, we have now seen two reasons why graph isomorphism does not allow the kind of handling we hope for in behavioral equivalences.
Thus, the following will focus on equivalences of bisimilarity and below.
The next section will revisit a deeper, philosophical reason why bisimilarity is a reasonable limit of the properties one might care about in the comparison of processes.

## Modal Logic {#sec-hml}

Modal logics are logics in which one can formalize how facts in one possible world relate to other possible worlds.
In the computer science interpretation, the possible worlds are *program states*, and typical statements have the form:
“If $X$ happens during the execution, then $Y$ will happen in the next step.”

We care about modal logics as they too can be used to characterize behavioral equivalences.
In this section, we will show how this characterization works and argue that, for our purposes of comparative semantics, modal characterizations are a superb medium.

### Hennessy–Milner Logic to Express Observations

@hm1980hml introduce the modal logic that is now commonly called *Hennessy–Milner logic* as a “little language for talking about programs.”
The idea is that HML formulas express “experiments” or “tests” that an observer performs interacting with a program.

::: {#def-hml}
#### Hennessy–Milner Logic

Formulas of *Hennessy–Milner logic* $\hml$ are given by the grammar:{{<isb datatype Hennessy_Milner_Logic hml_formula>}}

$$
\begin{array}{rcllr}
  φ & \grammardef &
    \hmlobs{α}φ & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    & \grammaror & \hmland{i}{I}φ_i & \quad\text{with index set } I & \text{“conjunction”} \\
    & \grammaror & \hmlneg φ & & \text{“negation”} \\
\end{array}
$$
:::

We also write conjunctions as sets $\hmlands \set{φ_1, φ_2…}$.
The empty conjunction $\hmlands \varnothing$ is denoted by $\hmltrue$ and serves as the nil-element of HML syntax trees.
We also usually omit them when writing down formulas, e.g., shortening $\hmlobs{\literal a}\hmlobs{\literal b}\hmltrue$ to $\hmlobs{\literal a}\hmlobs{\literal b}$.

We will assume a form of associativity through the *convention that conjunctions are flat* in the sense that they do not immediately contain other conjunctions.
In this sense, we consider $\hmlands \set{ φ_1, \hmlands \set{φ_2} }$ and $\hmlands \set{ φ_1, \hmlands \set{φ_2}, \hmltrue}$ just as different representatives of the flattened formula $\hmlands \set{φ_1, φ_2}$.

The intuition behind HML is that it describes *what sequences of behavior* one may or may not *observe* of a system.
Observations $\hmlobs{α}…$ are used to build up possible action sequences;
conjunctions $\hmlands\set{…}$ capture branching points in decision trees;
and negations $\hmlneg …$ describe impossibilities.

::: {#def-hml-semantics}
#### HML semantics

The semantics of HML $\semantics{\cdot} \colon \hml → \powerset{\states}$ is defined recursively by:{{<isb primrec Hennessy_Milner_Logic lts.satisfies>}}

$$
\begin{array}{rcl}
  \semantics{\hmlobs{α}φ} & ≔ & \set{p \mid \exists p' ∈ \semantics{φ} \ldotp p \step α p'}\\
  \semantics{\hmland{i}{I}φ_i} & ≔ & \bigcap_{i ∈ I} \semantics{φ_i}\\
  \semantics{\hmlneg φ} & ≔ & \states \setminus \semantics{φ}
\end{array}
$$
:::

::: {#exm-hml}
Let us consider some observations on the system of @exm-ts.

- $\semantics{\hmlobs{τ}\hmlobs{\literal a}} = \set{\literal P, \literal Q}$ as both, $\literal P$ and $\literal Q$, expose the trace $τ\literal{a}$,
- $\literal Q ∈ \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$, but $\literal P \notin \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$.
- $\literal P ∈ \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$, but $\literal Q \notin \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$.
:::

### Characterizing Bisimilarity via HML

We can now add the middle layer of our overview graphic in @fig-equivalence-big-picture:
That two states are bisimilar precisely if they cannot be told apart using HML formulas.

::: {#def-distinctions}
#### Distinctions and Equivalences

We say that formula $φ ∈ \hml$ *distinguishes* state $p$ *from* state $q$ if $p ∈ \semantics{φ}$ but $q \notin \semantics{φ}$.{{<isb abbreviation LTS_Semantics lts.distinguishes>}}

We say a sublogic $\observationsvar{} ⊆ \hml$ *preorders* state $p$ to $q$, $p \bpreordvar{\observationsvar{}} q$, if no $φ ∈ \observationsvar{}$ is distinguishing $p$ from $q$.{{<isb definition LTS_Semantics lts.preordered>}}
If the preordering goes in both directions, we say that $p$ and $q$ are equivalent with respect to sublogic $\observationsvar{}$, written $p \beqvar{\observationsvar{}} q$.{{<isb definition LTS_Semantics lts.equivalent>}}
:::

By this account, $\hmlobs{τ}\hmlneg\hmlobs{\literal a}$ of @exm-hml distinguishes $\literal P$ from $\literal Q$.
On the other hand, $\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}$ distinguishes $\literal Q$ from $\literal P$.
(The direction matters!)
For instance, the sublogic $\set{\hmlobs{τ}\hmlobs{\literal a}, \hmlobs{τ}\hmlobs{\literal b}}$ preorders $\literal P$ and $\literal Q$ in both directions; so the two states are equivalent with respect to this logic.


::: {#prp-hml-eq}
Consider an arbitrary HML sublogic $\observationsvar{} ⊆ \hml$.
Then, $\bpreordvar{\observationsvar{}}$ is a preorder, and $\beqvar{\observationsvar{}}$ an equivalence relation.{{<isb lemma LTS_Semantics lts.equivalent_equiv>}}
:::

::: {#lem-hml-eq-sim}
Hennessy–Milner logic equivalence $\beqvar{\hml}$ is a simulation relation.{{<isb lemma HML_Spectrum lts.hml_equiv_sim>}}
:::

::: proof
Assume it were not.
Then there would need to be $p \beqvar{\hml} q$ with step $p \step α p'$, and no $q'$ such that $q \step α q'$ and $p' \beqvar{\hml} q'$.
So there would need to be a distinguishing formula $φ_{q'}$ for each $q'$ that $q$ can reach by an $α$-step.
Consider the formula $φ_α ≔ \hmlobs{α}\hmland{q'}{\derivatives{q, α}} φ_{q'}$.
It must be true for $p$ and false for $q$, contradicting $p \beqvar{\hml} q$.
:::

::: {#lem-hml-eq-bisim-invariant}
#### HML Bisimulation Invariance

If $p ∈ \semantics{φ}$ and $p \beq{B} q$ then $q ∈ \semantics{φ}$.{{<isb lemma HML_Spectrum lts.hml_bisim_invariant>}}
:::

::: proof
Induct over the structure of $φ$ with arbitrary $p$ and $q$.

- Case $p ∈ \semantics{\hmlobs{α}φ}$.
  Thus there is $p' ∈ \semantics{φ}$ with $p \step α p'$.
  Because $\beq{B}$ is a simulation according to @lem-bisim-bisim, this implies $q'$ with $p' \beq{B} q'$.
  The induction hypothesis makes $p' ∈ \semantics{φ}$ entail $q' ∈ \semantics{φ}$
  and thus $q ∈ \semantics{\hmlobs{α}φ}$.
- Case $p ∈ \semantics{\hmland{i}{I}φ_i}$.
  The induction hypothesis on the $φ_i$ directly leads to
  $q ∈ \semantics{\hmland{i}{I}φ_i}$.
- Case $p ∈ \semantics{\hmlneg φ}$.
  Symmetry of $\beq{B}$ according to @prp-sim-eq-rel, implies $q \beq{B} p$.
  By induction hypothesis, $q ∈ \semantics{φ}$ implies $p ∈ \semantics{φ}$.
  So, using contraposition, the case implies $q ∈ \semantics{\hmlneg φ}$.\qedhere
:::

{{<noindent>}}Combining the bisimulation invariance for one direction and that $\beq{\hml}$ is a symmetric simulation (@prp-hml-eq and @lem-hml-eq-sim) for the other, we obtain that $\hml$ precisely characterizes bisimilarity:

::: {#thm-hennessy-milner}
#### Hennessy–Milner Theorem

Bisimilarity and HML equivalence coincide, that is, $p \beq{B} q$ precisely if $p \beq{\hml} q$.{{<isb theorem HML_Spectrum lts.Hennessy_Milner_theorem>}}
:::

::: {#rem-image-finiteness}
In the standard presentation of the theorem, image finiteness of the transition system is assumed.
This means that $\derivatives{p, α}$ is finite for every $p ∈ \states$.
The amount of outgoing transitions matters precisely in the construction of $φ_α$ in the proof of @lem-hml-eq-sim.
But as our definition of $\hml$ (@def-hml) allows infinite conjunctions $\hmland{i}{I} …$, we do not need an assumption here.
The implicit assumption is that the cardinality of index sets $I$ can match that of $\derivatives{p, α}$.
The original proof by @hm1980hml uses binary conjunction ($\varphi_1 \land \varphi_2$) and thus can only express finitary conjunctions.
:::

### The Perks of Modal Characterizations {#sec-perks-modal-characterizations}

There is merit in also characterizing other equivalences through sublogics $\observationsvar{} \subseteq \hml$.
There are four immediate big advantages to modal characterization:

Modal characterizations lead to *proper preorders and equivalences by design* due to @prp-hml-eq.
That is, if a behavioral preorder (or equivalence) is defined through modal logics, there is no need of proving transitivity and reflexivity (and symmetry).

Secondly, checking state equivalence for notions of $\hml$-sublogics *can soundly be reduced to checks on bisimulation-minimized systems* as the transformation does not affect the sets of observations for minimized states (by combining @thm-hennessy-milner and @prp-bisim-minimization).

Thirdly, modal characterizations can directly *unveil the hierarchy between preorders*, if defined cleverly, because of the following property.

::: {#prp-difference-contraposition}
If $\observationsvar{} \subseteq \observationsvar[\prime]{}$ then $p \bpreordvar{\observationsvar[\prime]{}} q$ implies $p \bpreordvar{\observationsvar{}} q$ for all $p,q$.{{<isb lemma LTS_Semantics lts_semantics.preorder_contraposition>}}
:::

Pay attention to the opposing directions of $\subseteq$ and implication, here!

Fourthly, as a corollary of @prp-difference-contraposition, modal characterizations *ensure equivalences to be abstractions of bisimilarity*, which is a sensible base notion of equivalence.^[
  Among other things, bisimilarity checking has a better time complexity than other notions as will be discussed in Subsection [-@sec-equivalence-complexities].
]

In Chapter [-@sec-spectrum], we will discuss how the hierarchy of behavioral equivalences can be understood nicely and uniformly if viewed through the modal lense.

### Expressiveness and Distinctiveness

@prp-difference-contraposition actually is a weak version of another proposition about *distinctiveness* of logics.

::: {#def-leq-expressive}
We say that an $\actions$-observation language $\observationsvar{}$ is *less or equal in expressiveness* to another $\observationsvar[\prime]{}$ iff, for any $\actions$-transition system, for each $φ ∈ \observationsvar{}$, there is $φ' ∈ \observationsvar[\prime]{}$ such that $\semantics{φ} = \semantics{φ'}$.
(The definition can also be read with regards to a fixed transition system $\system$.){{<isb definition LTS_Semantics lts_semantics.leq_expressive>}}
If the inclusion holds in both directions, $\observationsvar{}$ and $\observationsvar[\prime]{}$ are *equally expressive*.
:::

::: {#def-leq-distincitve}
We say that an $\actions$-observation language $\observationsvar{}$ is *less or equal in distinctiveness* to another $\observationsvar[\prime]{}$ iff, for any $\actions$-transition system and states $p$ and $q$, for each $φ ∈ \observationsvar{}$ that distinguishes $p$ from $q$, there is $φ' ∈ \observationsvar[\prime]{}$ that distinguishes $p$ from $q$.{{<isb definition LTS_Semantics lts_semantics.leq_distinctive>}}
If the inclusion holds in both directions, $\observationsvar{}$ and $\observationsvar[\prime]{}$ are *equally distinctive*.
:::

::: {#lem-subset-expressiveness-distinctiveness}

Subset relationship entails expressiveness entails distinctiveness.

- If $\observationsvar{} ⊆ \observationsvar[\prime]{}$, then $\observationsvar{}$ is less or equal in expressiveness to $\observationsvar[\prime]{}$.{{<isb lemma LTS_Semantics lts_semantics.subset_expressiveness>}}
- If $\observationsvar{}$ is less or equal in expressiveness to $\observationsvar[\prime]{}$, then $\observationsvar{}$ is less or equal in distinctiveness to $\observationsvar[\prime]{}$.{{<isb lemma LTS_Semantics lts_semantics.expressiveness_entails_distinctiveness>}}
:::

The other direction does not hold.
For instance, $\hml ⊈ \hml \setminus \set{\hmltrue}$, but they are equally expressive as $\hmlneg\hmlneg\hmltrue$ can cover for the removed element.
At the same time, $\set{\hmltrue}$ is more expressive than $\varnothing$, but equally distinctive.

The stronger version of @prp-difference-contraposition is thus:

::: {#prp-distinctiveness-contraposition}
If $\observationsvar{}$ is less or equal *in distinctiveness* to $\observationsvar[\prime]{}$ then $p \bpreordvar{\observationsvar[\prime]{}} q$ implies $p \bpreordvar{\observationsvar{}} q$ for all $p,q$.{{<isb lemma LTS_Semantics lts_semantics.preorder_expressiveness_contraposition>}}
:::

::: {#rem-flattened-conjunctions}
Through the lense of expressiveness, we can also justify why our convention to implicitly flatten conjunctions is sound:
As this does not change a conjunction's truth value, $\hml$ subsets with and without flattening-convention are equally expressive and thus distinctive.
:::

Often, an equivalence may be characterized by different sublogics.
In particular, one may find smaller characterizations as in the following example for bisimilarity.

::: {#def-game-formulas}

Consider $\observations{\floor{B}} \subseteq \hml$ described by the following grammar.

$$
\begin{array}{rcll}
  φ^\mathrm{\floor{B}}
    & \grammardef & \hmlobs{α} \hmland{i}{I} φ^\mathrm{\floor{B}}_i \\
    & \grammaror  & \hmlneg φ^\mathrm{\floor{B}}
\end{array}
$$
:::

$\observations{\floor{B}}$ is a proper subset of $\hml$.
For instance, it lacks the observation $\hmlobs{\literal a} \hmlobs{\literal b} \hmltrue$.
Due to the subset relation, $\observations{\floor{B}}$ must be less or equal in expressiveness to $\hml$, but this inclusion too is strict as $\hmltrue$ cannot be covered for.
But both logics are equally distinctive!

::: {#lem-game-formula-hml}
$\observations{\floor{B}}$ and $\hml$ are equally distinctive.{{<isb theorem HML_Spectrum lts.hml_and_bisimulation_game_observations_equally_expressive>}}
:::
::: proof

One direction is immediate from @lem-subset-expressiveness-distinctiveness as $\observations{\floor{B}} \subseteq \hml$.

For the other direction, we need to establish that for each $φ ∈ \hml$ distinguishing some $p$ from some $q$, there is a $φ' ∈ \observations{\floor{B}}$ distinguishing $p$ from $q$.
We induct on the structure of $φ$ with arbitrary $p$ and $q$.

- Case $\hmlobs{α}φ$ distinguishes $p$ from $q$.
  Thus there is $p'$ with $p \step α p'$ distinguishing $p'$ from all $q' ∈ \derivatives{q, α}$.
  By induction hypothesis, there must be $φ'_{q'} ∈ \observations{\floor{B}}$ distinguishing $p'$ from $q'$ for each $q'$.
  Thus $\hmlobs{α}\hmland{q'}{\derivatives{q, α}} φ'_{q'} ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.
- Case $\hmland{i}{I}φ_i$ distinguishes $p$ from $q$.
  Therefore some $φ_i$ already distinguishes $p$ from $q$.
  By induction hypothesis, there must be $φ'_i ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.
- Case $\hmlneg φ$ distinguishes $p$ from $q$.
  Thus $φ$ distinguishes $q$ from $p$.
  By induction hypothesis, there is $φ' ∈ \observations{\floor{B}}$ distinguishing $q$ from $p$.
  Accordingly, $\hmlneg φ' ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.\qedhere
:::

The smaller bisimulation logic $\observations{\floor{B}}$ will become important again later in the next section (in Subsection [-@sec-bisim-game-hml]).

## Games {#sec-games}

So far, we have only seen behavioral equivalences and modal formulas as mathematical objects and not cared about decision procedures.
This section introduces *game-theoretic characterizations* as a way of easily providing decision procedures for equivalences and logics alike.
Intuitively, the games can be understood as dialogs between a party that tries to defend a claim and a party that tries to attack it.

### Reachability Games

We use *Gale--Stewart-style reachability games* [in the tradition of @galeStewart1953infiniteGamesPerfectInformation] where the defender wins all infinite plays.

::: {#def-game}
#### Reachability Game

A *reachability game* $\game = (G, G_\defender, \gamemoveblank)$ is played on a directed graph consisting of

- a set of *game positions* $G$, partitioned into
  - *defender positions* $G_\defender ⊆ G$
  - and *attacker positions* $G_\attacker ≔ G \setminus G_\defender$,
- and a set of *game moves* ${\gamemoveblank} ⊆ G × G$.{{<isb locale Equivalence_Games game>}}

{{<noindent>}} We denote by $\game(g_0)$ the game played from starting position $g_0 ∈ G$.
:::

::: {#def-game-plays}
#### Plays and Wins

We call the paths ${g_0}{g_1} … ∈ G^{\infty}$ with $g_{i} \gamemoveblank g_{i+1}$ *plays* of $\game(g_0)$.
They may be finite or infinite.
The defender *wins* infinite plays.
If a finite play $g_{0}\dots g_{n}\!\ngamemoveblank$ is stuck, the stuck player loses: The defender wins if $g_{n} ∈ G_\attacker$, and the attacker wins if $g_{n}∈ G_\defender$.
:::

\noindent
Usually, games are non-deterministic, that is, players have choices how a play proceeds at their positions.
The player choices are formalized by *strategies*:

::: {#def-strategies}
#### Strategies and Winning Strategies

An *attacker strategy* is a (partial) function mapping play fragments ending at attacker positions to next positions to move to, $s_\attacker \colon G^*G_\attacker \to G$, where $g_\attacker \gamemoveblank f_\attacker(\rho g_\attacker)$ must hold for all $\rho g_\attacker$ where $s_\attacker$ is defined.

A play ${g_0}{g_1} … ∈ G^{\infty}$ is consistent with an attacker strategy $s_\attacker$ if, for all its prefixes $g_0 … g_i$ ending in $g_i \in G_\attacker$, $g_{i + 1} = s_\attacker(g_0 … g_i)$.

*Defender strategies* are defined analogously, $s_\defender \colon G^*G_\defender \to G$.

If $s$ ensures a player to win, $s$ is called a *winning strategy* for this player.
The player with a winning strategy for $\game(g_{0})$ is said to *win* $\game(g_{0})$.

Usually, we will focus on positional strategies, that is, strategies that only depend on the most recent position, which we will type $s_\attacker \colon G_\attacker \to G$ (or $s_\defender \colon G_\defender \to G$, respectively).
:::

{{<noindent>}}
We call the positions where a player has a winning strategy their winning region.

::: {#def-winning-region}
#### Winning Region

The set $\attackerwins ⊆ G$ of all positions $g$ where the attacker wins $\game(g)$ is called the *attacker winning region* of $\game$.
The defender winning region $\defenderwins$ is defined analogously.
:::

::: {#exm-formula-game}
#### A Simple Choice

Inspect the game in @fig-game-ex, where round nodes represent defender positions and rectangular ones attacker positions.
Its valid plays starting from $(\literal{1})$ are
$(\literal{1})$,
$(\literal{1})[\literal{2a}]$,
$(\literal{1})[\literal{2b}]$, and
$(\literal{1})[\literal{2a}](\literal{3})$.
The defender can win from $(\literal{1})$ with a strategy moving to $[\literal{2b}]$ where the attacker is stuck.
Moving to $[\literal{2a}]$ instead would get the defender stuck.
So, the defender winning region is $\defenderwins = \set{(\literal{1}),[\literal{2b}]}$ and the attacker wins $\attackerwins = \set{[\literal{2a}], (\literal{3})}$.

:::: {#fig-game-ex .column-margin}
```{mermaid}
%%| fig-width: 1.5
flowchart TD
  1([1]) --> 2a[2a] --> 3([3])
  1 --> 2b[2b]
```
A simple game.
::::
:::

\noindent
The games we consider are positionally determined.
This means, for each possible initial position, exactly one of the two players has a positional winning strategy $s$.

::: {#prp-determinacy}
#### Determinacy

Reachability games are positionally determined, that is,
for any game, each game position has exactly one winner:
$G = \attackerwins \cup \defenderwins$ and $\attackerwins \cap \defenderwins = \varnothing$,
and they can win using a positional strategy.^[
  This is just an instantiation of positional determinacy of parity games [@zielonka1998infiniteGameColoured].
  Reachability games are the subclass of parity games only colored by 0.
]
:::

\noindent
We care about reachability games because they are versatile in characterizing formal relations.
Everyday inductive (and coinductive) definitions can easily be encoded as games as in the following example.

::: {#exm-less-eq-game}
#### The $\leq$-Game

Consider the following recursive definition of a less-or-equal operator `≤` on natural numbers in some functional programming language.
(Consider `nat` to be defined as recursive data type `nat = 0 | Succ nat`.)

```haskell
    ( 0 ≤ m )     = True
(Succ n ≤ 0 )     = False
(Succ n ≤ Succ m) = (n ≤ m)
```

\noindent
We can think of this recursion as a game where the attacker tries to prove that the left number is bigger than the right by always decrementing the left number and challenging the defender to do the same for the right stack too.
Whoever hits zero first, loses.

This means we distribute the roles such that the defender wins for output `True` and the attacker for output `False`.
The two base cases need to be dead ends for one of the players.

Formally, the game $\game_\literal{leq}$ consists of attacker positions $[n,m]$ and defender positions $(n,m)$ for all $n,m \in \nats$, connected by chains of moves:
$$
\begin{array}{rcl}
    [n + 1, m]
    & \gamemoveblank_\literal{leq}
    & (n, m)\\
    (n, m + 1)
    & \gamemoveblank_\literal{leq}
    & [n, m].
\end{array}
$$

\noindent
$\game_\literal{leq}$ now characterizes $\leq$ on $\nats$ in the sense that:
The defender wins $\game_\literal{leq}$ from $[n, m]$ precisely if $n \leq m$.
(Proof: Induct over $n$ with arbitrary $m$.)

The game is *boring* because the players do not ever have any choices.
They just count down their way through the natural numbers till they hit $[0, m - n]$ if $n \leq m$, or $(n - m, 0)$ otherwise.

$\game_\literal{leq}$ is quite archetypical for the preorder and equivalence games we will use in the following pages.
But do not worry, the following games will demand the players to make choices.
:::

### The Semantic Game of HML

As first bigger example of how recursive definitions can be turned into games, let us quickly look at a standard way of characterizing the semantics of HML (@def-hml-semantics) through a game.
The defender wins precisely if the game starts from a state and formula such that the state satisfies the formula.

::: {#def-hml-game}
#### HML Game

For a transition system $\system = (\states,\actions,\step{})$,
the $\hml$ *game* ${\game}_\hml^{\system} = (G_\hml,G_\defender,\gamemoveblank_\hml)$ is played on $G_\hml = \states × \hml$,
where the defender controls observations and negated conjunctions,
that is $(p, \hmlobs{α}φ) ∈ G_\defender$ and
$(p,\hmlneg\hmland{i}{I}φ_i) ∈ G_\defender$ (for all $φ,p,I$), and the attacker controls the rest.

- The defender can perform the moves:
  $$
  \begin{array}{rclr}
      (p, \hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
      (p, \hmlneg{\hmland{i}{I}φ_i})
      & \gamemoveblank_\hml
      & (p, \hmlneg φ_i)
      & \text{ with $i ∈ I$;}
  \end{array}
  $$
- and the attacker can move:
  $$
  \begin{array}{rclr}
    (p, \hmlneg\hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', \hmlneg φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
    (p, \hmland{i}{I}φ_i)
      & \gamemoveblank_\hml
      & (p, φ_i)
      & \text{ with $i ∈ I \quad$ and} \\
    (p, \hmlneg\hmlneg φ)
      & \gamemoveblank_\hml
      & (p, φ).
      &
  \end{array}
  $$
:::

\noindent
The intuition is that disjunctive constructs ($\hmlobs{\cdot}\cdots$, $\hmlneg \hmlands \cdots$) make it easier for a formula to be true and thus are controlled by the defender who may chose which of the ways to show truth is most convenient.
At conjunctive constructs ($\hmlneg\hmlobs{\cdot}\cdots$, $\hmlands \cdots$) the attacker choses the option that is the easiest to disprove.

::: {#exm-formula-game-cont}

The game of @exm-formula-game is exactly the HML game ${\game}_\hml^{\system_\literal{PQ}}$ for formula $\hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue$ and state $\literal P$ of @exm-hml with
$(\literal{1}) ≔ (\literal{P}, \hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2a}] ≔ (\literal{p_a}, \hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2b}] ≔ (\literal{p_b}, \hmlneg\hmlobs{\literal a}\hmltrue)$, and
$(\literal{3}) ≔ (\literal{p_1}, \hmlneg\hmltrue)$.

The defender winning region $\defenderwins = \set{(\literal{P}, \hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue), (\literal{p_b}, \hmlneg\hmlobs{\literal a}\hmltrue)}$ corresponds to the facts that $\literal{P} \in \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue}$ and $\literal{p_b} \in \semantics{\hmlneg\hmlobs{\literal a}\hmltrue}$.
:::

\noindent
As the technicalities are tangential to this thesis, we state the characterization result without proof:^[
  A detailed presentation of a more general HML game, also extending to recursive HML, can be found in @woe2015caal2hml [Chapter 3].
]

::: {#lem-hml-semantic-game}
The defender wins ${\game}_\hml^{\system}((p, φ))$ precisely if $p ∈ \semantics{φ}$.
:::

### The Bisimulation Game

We now can add the bottom layer of @fig-equivalence-big-picture:
That bisimilarity can be characterized through a game.
This approach has been popularized by @stirling1996modal.

::: {#def-bisim-game}
#### Bisimulation Game

For a transition system $\system$, the *bisimulation game* ${\game}_\notionname{B}^{\system}$ is played on
attack positions $G^\notionname{B}_\attacker ≔ \states × \states$ and defense positions $G^\notionname{B}_\defender ≔ \actions × \states × \states$ with the following moves:{{<isb locale Equivalence_Games bisim_game>}}

- The attacker may *swap sides*
  $$[p, q] \quad \gamemoveblank_\notionname{B} \quad [q, p],$$
- or *challenge simulation*
  $$[p, q] \quad \gamemoveblank_\notionname{B} \quad (α, p', q) \quad \text{if} \quad p \step{α} p';$$
- and the defender *answers simulation challenges*
  $$(α, p', q) \quad \gamemoveblank_\notionname{B} \quad [p', q'] \quad \text{if} \quad q \step{α} q'.$$
:::

A schematic depiction of the game rules can be seen in @fig-game-scheme.
From dashed nodes, the game proceeds analogously to the initial attacker position.

::: {#fig-game-scheme fig-pos='t'}

```tikz
\begin{tikzpicture}[>->,shorten <=1pt,shorten >=0.5pt,auto,node distance=2cm, rel/.style={dashed,font=\it},
  posStyle/.style={draw, inner sep=1ex,minimum size=1cm,minimum width=2cm,anchor=center,draw,black,fill=gray!5}]
    \node[posStyle, initial, initial text={}]
      (Att){$[p,q]$};
    \node[ellipse, draw, inner sep=1ex, minimum size=1cm,minimum width=2cm,fill=gray!5]
      (Def) [right = 1.5cm of Att] {$(\alpha, p', q)$};
    \node[posStyle, dashed]
      (AttContinue) [right = 1.5cm of Def] {$[p', q']$};
    \node[posStyle, dashed]
      (AttContinueSwap) [below = 1.2cm of AttContinue] {$[q, p]$};
    \path
      (Att)
        edge node {$p \step{\alpha} p'$} (Def)
        edge[bend right=10] node {} (AttContinueSwap)
      (Def)
        edge node {$q \step{\alpha} q'$} (AttContinue);
\end{tikzpicture}
```

Game scheme of the bisimulation game (@def-bisim-game).
:::

::: {#exm-bisim-game}
Consider $\literal{p_{even}} \beq{B} \literal{p_{odd}}$ of @exm-graph-isomorphism.
The bisimulation game on this system is given by @fig-bisim-game-even-odd:

:::: {#fig-bisim-game-even-odd}
  ```tikz
  \begin{tikzpicture}[>->, shorten <=1pt, shorten >=0.5pt, auto, node distance=4cm,
    posStyle/.style={draw, inner sep=1ex, minimum size=1cm, minimum width=2.25cm, anchor=center, draw, black, fill=gray!5},
    defender/.style={ellipse, inner sep=0ex},
    defWins/.style={fill=blue!5}]

    \node[posStyle, initial, initial text={}]
      (Att_EO){$[\literal{p_{even}}, \literal{p_{odd}}]$};
    \node[posStyle, defender]
      (Dfn_tOO) [below left of=Att_EO] {$(\tau, \literal{p_{odd}}, \literal{p_{odd}})$};
    \node[posStyle, defender]
      (Dfn_tEE) [below right of=Att_EO] {$(\tau, \literal{p_{even}}, \literal{p_{even}})$};
    \node[posStyle]
      (Att_OE) [below right of=Dfn_tOO] {$[\literal{p_{odd}}, \literal{p_{even}}]$};

    \path
      (Att_EO)
        edge[bend left = 10] node {swap} (Att_OE)
        edge[bend right = 10, swap] node {challenge} (Dfn_tOO)
      (Att_OE)
        edge[bend left = 10] node {swap} (Att_EO)
        edge[bend right = 10, swap] node {challenge} (Dfn_tEE)
      (Dfn_tOO)
        edge[bend right = 10, swap] node {answer\vphantom{lg}} (Att_OE)
      (Dfn_tEE)
        edge[bend right = 10, swap] node {answer\vphantom{lg}} (Att_EO)
    ;
  \end{tikzpicture}
  ```
  Bisimulation game under $\literal{p_{even}}, \literal{p_{odd}}$.
  Moves are annotated with the game rules from which they derive.
::::

\noindent
Clearly, there is no way for the attacker to get the defender stuck.
Whatever strategy the attacker choses, the game will go on forever, leading to a win for the defender.
That it is always safe for the defender to *answer* with moves to $[\literal{p_{even}}, \literal{p_{odd}}]$ and $[\literal{p_{odd}}, \literal{p_{even}}]$ corresponds to $\rel R ≔ \set{(\literal{p_{even}}, \literal{p_{odd}}), (\literal{p_{odd}}, \literal{p_{even}})}$ being a bisimulation.
:::

::: {#exm-bisim-sim-game}
Let us recall @exm-bisim-sim of the “trolled philosophers,” where we determined $\literal{Q}$ and $\literal{T}$ to be non-bisimilar.
The bisimulation game graph for the system is depicted in @fig-bisim-sim-game.

The attacker can win by moving $[\literal{Q}, \literal{T}]
\gamemoveblank_\notionname{B} [\literal{T}, \literal{Q}]
\gamemoveblank_\notionname{B} (\tau, \literal{q_3}, \literal{Q})
\gamemoveblank_\notionname{B} [\literal{q_3}, \literal{q_{AB}}]
\gamemoveblank_\notionname{B} [\literal{q_{AB}}, \literal{q_3}]
\gamemoveblank_\notionname{B} (\literal{a}, \literal{q_1}, \literal{q_3})
\ngamemoveblank_\notionname{B}$.
Along this sequence of positions, the defender never has a choice and is stuck in the end.
The attacker exploits, that $\literal{T}$ can reach an early deadlock via $\literal{T} \step{\tau} \literal{q_{3}}$.
:::

::: {#fig-bisim-sim-game fig-pos='t' fig-env="figure*"}
```tikz
  \begin{tikzpicture}[>->, shorten <=1pt, shorten >=0.5pt, auto, node distance=2cm,
    posStyle/.style={draw, inner sep=1ex, minimum size=1cm, minimum width=2.25cm, anchor=center, draw, black, fill=gray!5},
    defender/.style={ellipse, inner sep=0ex},
    defWins/.style={fill=blue!5}]

    \node[posStyle, initial, initial text={}]
      (Att_Q_Qp){$[\literal{Q}, \literal{T}]$};
    \node[posStyle]
      (Att_Qp_Q) [below = 2cm of Att_Q_Qp] {$[\literal{T}, \literal{Q}]$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Qp) [right = 1.5cm of Att_Q_Qp] {$(\tau, \literal{q_{AB}}, \literal{T})$};
    \node[posStyle, defWins]
      (Att_qab_qab) [below right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_{AB}}]$};
    \node[posStyle]
      (Att_qab_q3) [above right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_3}]$};
    \node[posStyle, defender]
      (Dfn_a_q1_q3) [above right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{a}, \literal{q_1}, \literal{q_3})$};
    \node[posStyle, defender]
      (Dfn_b_q2_q3) [below right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{b}, \literal{q_2}, \literal{q_3})$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Q) [below = 1cm of Dfn_t_qab_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q})$};
    \node[posStyle, defender]
      (Dfn_t_q3_Q) [below = 1cm of Dfn_t_qab_Q] {$(\tau, \literal{q_{3}}, \literal{Q})$};
    \node[posStyle]
      (Att_q3_qab) [below = 1cm of Att_qab_qab] {$[\literal{q_3}, \literal{q_{AB}}]$};

    \path
      (Att_Q_Qp)
        edge[bend left = 10] node {swap} (Att_Qp_Q)
        edge node {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Dfn_t_qab_Qp)
      (Att_qab_q3)
        edge[bend left = 65] node {swap} (Att_q3_qab)
      (Att_q3_qab)
        edge[bend right = 60] node {} (Att_qab_q3)
      (Dfn_t_qab_Qp)
        edge node {$\literal{T} \step{\tau} \literal{q_{3}}$} (Att_qab_q3)
        edge node {$\literal{T} \step{\tau} \literal{q_{AB}}$} (Att_qab_qab)
      (Att_qab_qab)
        edge [loop left] node {swap} ()
      (Att_Qp_Q)
        edge[bend left = 10] node {swap} (Att_Q_Qp)
        edge[swap] node {$\literal{T} \step{\tau} \literal{q_{AB}}$} (Dfn_t_qab_Q)
        edge[swap] node {$\literal{T} \step{\tau} \literal{q_{3}}$} (Dfn_t_q3_Q)
      (Dfn_t_qab_Q)
        edge node[swap] {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Att_qab_qab)
      (Dfn_t_q3_Q)
        edge node[swap] {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Att_q3_qab)
      (Att_qab_q3)
        edge node {$\literal{q_{AB}} \step{\literal{a}} \literal{q_1}$} (Dfn_a_q1_q3)
        edge node {$\literal{q_{AB}} \step{\literal{b}} \literal{q_2}$} (Dfn_b_q2_q3)
    ;
  \end{tikzpicture}
```

Bisimulation game on non-bisimilar states $\literal{Q}$ and $\literal{T}$ of @exm-bisim-sim-game.
Moves are labeled by their justification.
Defender-won positions are tinted blue.
:::

::: {#thm-bisim-game-characterization}
#### Stirling's Game Characterization

The defender wins the bisimulation game ${\game}_\notionname{B}^{\system}$ starting at attacker position $[p, q]$ precisely if $p \beq{B} q$.{{<isb theorem Equivalence_Games bisim_game.bisim_game_characterization>}}
:::
::: proof
Sketch for both directions:

- If $\rel R$ is a symmetric simulation with $(p,q) ∈ \rel R$,
  then the following positional defender strategy is well-defined and winning from $[p, q]$:{{<isb lemma Equivalence_Games bisim_game.bisim_implies_defender_winning_strategy>}}
  $$s (α, p', q) ≔ [p', \operatorname{choose} q'\ldotp (p', q') ∈ \rel R \land q \step{α} q'].$$
- If there is a positional defender strategy $s$ winning from $[p, q]$,
  then the following relation $\rel{R_s}$ with $(p_0,q_0) ∈ \rel{R_s}$ is a symmetric simulation:{{<isb lemma Equivalence_Games bisim_game.defender_winning_strategy_implies_bisim>}}
  $$\rel{R_s} ≔ \set{(p,q) \mid \text{there is a play $(p_0, q_0),\dots,(p,q)$ following strategy $s$}}.$$
:::

::: {#rem-computer-game}
One of the big advantages of game characterizations is that they provide a way to discuss equivalence and inequivalence interactively among humans.
There also are several computer game implementations of bisimulation games.

:::: {#fig-peacock-game .column-margin}
![](img/peacock-bisim-video-game.png){.lightbox}

Screenshot of [Peacock's bisimulation computer game](https://www.concurrency-theory.org/rvg-game/).
::::

For instance, @peacock2020videoGameEquivalences implements a game about simulation and bisimulation as well as several weaker notions.
The human plays the attacker trying to point out the inequivalence of systems according to the rules of @def-bisim-game.
@fig-peacock-game shows a screenshot of said game.
It can be played on <https://www.concurrency-theory.org/rvg-game/>.
:::

::: {#exm-leq-bisim-game}
If one plays the bisimulation game of @def-bisim-game without the swapping moves, it will characterize the simulation preorder.

Consider the family of processes $\literal{N}_n$ with $n \in \nats$.
Define $\literal{N}_0 := \ccsnull$ and $\literal{N}_{n + 1} := \ccsprefix{\literal{a}} \literal{N}_n$.
Then, the simulation game played from $[\literal{N}_{n}, \literal{N}_{m}]$ is isomorphic to the $\leq$-game $\game_{\literal{leq}}$ from @exm-less-eq-game.

In this sense, comparisons of programs and of numbers are … comparable.
:::

### How Bisimulation Game and HML Are Connected {#sec-bisim-game-hml}

Let us pause to think how bisimulation game and Hennessy–Milner logic connect.

You might have wondered why we even need a dedicated bisimulation game.
The Hennessy–Milner theorem implies that we could directly use the HML game of @def-hml-game to decide bisimilarity:

::: {#def-naive-bisim-game}

#### Naive Bisimulation Game

We extend the @def-hml-game by the following prefix:

1. To challenge $[p,q]$, the attacker picks a formula $φ ∈ \hml$ (claiming that $φ$ distinguishes the states) and yields to the defender $(φ, p, q)$.
2. The defender decides where to start the HML game:
    1. Either at $(p, \hmlneg φ)$ (claiming $φ$ to be non-distinguishing because it is untrue for $p$)
    2. or at $(q, φ)$ (claiming $φ$ to be non-distinguishing because it is true for $q$).
3. After that the turns proceed as prescribed by @def-hml-game.

:::

{{<noindent>}} This naive game, too, has the property that the defender wins from $[p,q]$ iff $p \beq{B} q$.
The downside of the game is that the attacker has infinitely many options $φ ∈ \hml$ to pick from!

The proper bisimulation game of @def-bisim-game, on the other hand, is *finite for finite transition systems*.
Therefore, it induces decision procedures.

We will now argue that the *bisimulation game actually is a variant of the naive game*, where (1) the attacker names their formula *gradually*, and (2) the formulas stem from $\observations{\floor{B}} \subseteq \hml$ of @def-game-formulas.
To this end, we will show that attacker's winning strategies imply distinguishing formulas, and that a distinguishing formula from $\observations{\floor{B}}$ certifies the existence of winning attacker strategies.

::: {#exm-bisim-sim-game-formulas}

Let us illustrate how to derive distinguishing formulas using the game of @exm-bisim-sim-game.

Recall that the attacker wins by moving $[\literal{Q}, \literal{T}]
\gamemoveblank_\notionname{B} [\literal{T}, \literal{Q}]
\gamemoveblank_\notionname{B} (\tau, \literal{q_3}, \literal{Q})
\gamemoveblank_\notionname{B} [\literal{q_3}, \literal{q_{AB}}]
\gamemoveblank_\notionname{B} [\literal{q_{AB}}, \literal{q_3}]
\gamemoveblank_\notionname{B} (\literal{a}, \literal{q_1}, \literal{q_3})
\ngamemoveblank_\notionname{B}$.
In @fig-bisim-sim-game-formulas, we label the game nodes with the (sub-)formulas this strategy corresponds to.
Swap moves become negations, and simulation moves become observations with a conjunction of formulas for each defender option.
This attacker strategy can thus be expressed by $\hmlneg\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue} \in \observations{\floor{B}}$.
:::

::: {#fig-bisim-sim-game-formulas fig-pos='t' fig-env="figure*"}
```tikz
%%| image-class: lightbox
  \begin{tikzpicture}[>->, shorten <=1pt, shorten >=0.5pt, auto, node distance=2cm,
    posStyle/.style={draw, inner sep=1ex, minimum size=1cm, minimum width=2.25cm, anchor=center, draw, black, fill=gray!5},
    defender/.style={ellipse, inner sep=0ex},
    defWins/.style={fill=blue!5}]

    \node[posStyle, initial, initial text={}, label={100:$\hmlneg\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue}$}]
      (Att_Q_Qp){$[\literal{Q}, \literal{T}]$};
    \node[posStyle, label={100:$\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue}$}]
      (Att_Qp_Q) [below = 2cm of Att_Q_Qp] {$[\literal{T}, \literal{Q}]$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Qp) [right = 1.5cm of Att_Q_Qp] {$(\tau, \literal{q_{AB}}, \literal{T})$};
    \node[posStyle, defWins]
      (Att_qab_qab) [below right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_{AB}}]$};
    \node[posStyle, label={100:$\hmlobs{\literal{a}}\hmltrue$}]
      (Att_qab_q3) [above right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_3}]$};
    \node[posStyle, defender, above right = .1cm and 1.5cm of Att_qab_q3]
      (Dfn_a_q1_q3) {$(\literal{a}, \literal{q_1}, \literal{q_3})$};
    \node[posStyle, defender]
      (Dfn_b_q2_q3) [below right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{b}, \literal{q_2}, \literal{q_3})$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Q) [below = 1cm of Dfn_t_qab_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q})$};
    \node[posStyle, defender]
      (Dfn_t_q3_Q) [below = 1cm of Dfn_t_qab_Q] {$(\tau, \literal{q_{3}}, \literal{Q})$};
    \node[posStyle, label={100:$\hmlneg\hmlobs{\literal{a}}\hmltrue$}]
      (Att_q3_qab) [below = 1cm of Att_qab_qab] {$[\literal{q_3}, \literal{q_{AB}}]$};

    \path
      (Att_Q_Qp)
        edge[bend left = 10] node {} (Att_Qp_Q)
        edge node {} (Dfn_t_qab_Qp)
      (Att_qab_q3)
        edge[bend left = 65] node {} (Att_q3_qab)
      (Att_q3_qab)
        edge[bend right = 60] node {} (Att_qab_q3)
      (Dfn_t_qab_Qp)
        edge node {} (Att_qab_q3)
        edge node {} (Att_qab_qab)
      (Att_qab_qab)
        edge [loop left] node {} ()
      (Att_Qp_Q)
        edge[bend left = 10] node {} (Att_Q_Qp)
        edge node {} (Dfn_t_qab_Q)
        edge node {} (Dfn_t_q3_Q)
      (Dfn_t_qab_Q)
        edge node {} (Att_qab_qab)
      (Dfn_t_q3_Q)
        edge node {} (Att_q3_qab)
      (Att_qab_q3)
        edge node {} (Dfn_a_q1_q3)
        edge node {} (Dfn_b_q2_q3)
    ;
  \end{tikzpicture}
```

The bisimulation game of @exm-bisim-sim-game-formulas with attacker formulas.
:::

\noindent
More generally, the following lemma explains the construction of distinguishing formulas from attacker strategies:

::: {#lem-attacks-imply-formulas}
Let $s$ be a positional winning strategy for the attacker on ${\game}_\notionname{B}$ from $[p,q]$.
Construct formulas recursively from game positions, ${φ}_{\rel{s}}(g)$, as follows:
$$
φ_{s}([p,q]) ≔ \begin{cases}
  \hmlneg φ_{s}([q,p])  & \text{if } s([p,q]) = [q,p] \\
  \hmlobs{\alpha} \hmlands \set{ φ_{s}([p',q']) \mid q \step{\alpha} q' } & \text{if } s([p,q]) = (\alpha,p',q)
\end{cases}
$$
\noindent
Then $φ_{s}([p,q])$ is well-defined and distinguishes $p$ from $q$.
Also, $φ_{s}([p,q]) ∈ \observations{\floor{B}}$.
:::
::: proof
1. The given construction is well-defined as $s$ must induce a well-founded order on game positions in order to be attacker-winning.
2. The distinction can be derived by induction on the construction of $φ_{s}([p,q])$.
   TODO \qedhere
:::

::: {#lem-formulas-imply-attack}
If $φ ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$, then the attacker wins from $[p,q]$.
:::
::: proof

By induction on the derivation of $φ ∈ \observations{\floor{B}}$ according to the definition from @def-game-formulas with arbitrary $p$ and $q$.

- Case $φ = \hmlobs{α} \hmland{i}{I} φ_i$.
  As $φ$ distinguishes $p$ from $q$, there must be a $p'$ such that $p \step{α} p'$ and that $\hmland{i}{I} φ_i$ distinguishes $p'$ from every $q' \in \derivatives{q, α}$.
  That is, for each $q' \in \derivatives{q, α}$, at least one $φ_i \in \observations{\floor{B}}$ must be false.
  By induction hypothesis, the attacker thus wins each $[p',q']$.
  As these attacker positions encompass all successors of $(α, p', q)$, the attacker also wins this defender position and can win from $[p,q]$ by moving there with a simulation challenge.
- Case $φ = \hmlneg φ'$.
  As $φ$ distinguishes $p$ from $q$, $φ'$ distinguishes $q$ from $p$.
  By induction hypothesis, the attacker wins $[q, p]$.
  So they can also win $[p, q]$ by performing a swap.\qedhere
:::

{{<noindent>}} @lem-attacks-imply-formulas and @lem-formulas-imply-attack, together with the fact that $\observations{\floor{B}}$ and $\hml$ are equally distinctive (@lem-game-formula-hml), yield:

::: {#thm-game-formulas}
The attacker wins ${\game}_\notionname{B}$ from $[p,q]$ precisely if there is $φ ∈ \hml$ distinguishing $p$ from $q$.
:::

{{<noindent>}} Of course, we already knew this!
@thm-game-formulas is just another way of gluing together the Hennessy–Milner theorem on bisimulation (@thm-hennessy-milner) and the Stirling's bisimulation game characterization (@thm-bisim-game-characterization), modulo the determinacy of games.
We thus have added the last arrow on the right side of @fig-equivalence-big-picture.

### Deciding Reachability Games

All we need to turn a game characterization into a decision procedure, is a way to decide which player wins a position.
@alg-deciding-games describes how to compute who wins a finite reachability game for each position in time linear to the size of the game graph $\relsize{\gamemoveblank}$.

::: {#alg-deciding-games}

$$
\begin{array}{lr}
  \kw{def} \variable{compute\_winning\_region}(\game=(G,G_\defender,\gamemoveblank)) \colon & \\
  \quad \variable{defender\_options} :=
    [g \mapsto n \mid g \in G \land n = \relsize{\set{g' \mid g \gamemoveblank g'}}] & \\
  \quad \variable{attacker\_win} := \varnothing & \\
  \quad \variable{todo} := \set{g\in G_\defender \mid \variable{defender\_options}[g]=0} & \\
  \quad \kw{while} \variable{todo} \neq \varnothing \colon & \\
  \quad \quad \variable{g} := \kw{some} \variable{todo} & \\
  \quad \quad \variable{todo} := \variable{todo} \setminus \set{\variable{g}} & \\
  \quad \quad \kw{if} \variable{g} \notin \variable{attacker\_win} \colon & \\
  % note: the if should not be necessary for sets.
  \quad \quad \quad \variable{attacker\_win} := \variable{attacker\_win} \cup \set{\variable{g}} & \\
  \quad \quad \quad \kw{for} \variable{g_{p}} \in (\cdot \gamemoveblank \variable{g}) \colon & \\
  \quad \quad \quad \quad \variable{defender\_options}[\variable{g_{p}}]:=\variable{defender\_options}[\variable{g_{p}}]-1 & \\
  \quad \quad \quad \quad \kw{if} \variable{g_{p}} \in G_\attacker \lor \variable{defender\_options}[\variable{g_{p}}]=0 \colon & \\
  \quad \quad \quad \quad \quad \variable{todo} := \variable{todo} \cup \set{\variable{g_{p}}} & \\
  \quad \attackerwins := \variable{attacker\_win} & \\
  \quad \kw{return} \attackerwins & \\
\end{array}
$$

Algorithm for deciding the attacker winning region $\attackerwins$ of a reachability game $\game$ in linear time of $\relsize{\gamemoveblank}$ and linear space of $\relsize{G}$.
:::

Intuitively, $\variable{compute\_winning\_region}$ first assumes that the defender were to win everywhere and that each outgoing move of every position might be a winning option for the defender.
Over time, every position that is determined to be lost by the defender is added to a $\variable{todo}$ list.^[
  Variants of this algorithm and explanation have also been used in @bisping2018coupledsim and @bjn2022decidingAllBehavioralEqs.
]

At first, the defender loses immediately exactly at the defender's dead-ends.
Each defender-lost position is added to the $\variable{attacker\_win}$ set.
To trigger the recursion, each predecessor is noted as defender-lost, if it is controlled by the attacker, or the amount of outgoing defender options is decremented if the predecessor is defender-controlled.
If the count of a predecessor position hits 0, the defender also loses from there.

Once we run out of $\variable{todo}$ positions, we know that the attacker has winning strategies exactly for each position we have visited.

The following @tbl-game-example-execution lists how @alg-deciding-games computes the winning region $\attackerwins = \set{[\literal{2a}], (\literal{3})}$ of the game of @def-game-formulas.

| $\variable{g}$ | $\variable{defender\_options}$ | $\variable{todo}$ |
|------|---------------|------|
|   -    |  $(\literal{1}) \mapsto 2$, $(\literal{3}) \mapsto 0$ | $(\literal{3})$  |
| $(\literal{3})$ | $(\literal{1}) \mapsto 2$, $(\literal{3}) \mapsto 0$ | $[\literal{2a}]$  |
| $[\literal{2a}]$ | $(\literal{1}) \mapsto 1$, $(\literal{3}) \mapsto 0$ | $\varnothing$ |

: Solving the game of @def-game-formulas {#tbl-game-example-execution fig-pos='b'}

\noindent
The inner loop of @alg-deciding-games clearly can run at most $\relsize{\gamemoveblank}$-many times.
Using sufficiently clever data structures, the algorithm thus shows:

::: {#prp-reachability-game-complexity}
Given a finite reachability game $\game=(G,G_\defender,\gamemoveblank)$,
the attacker's winning region $\attackerwins$ (and $\defenderwins$ as well) can be computed in $\bigo{\relsize{\gamemoveblank}}$ time and $\bigo{\relsize{G}}$ space.
:::

## Discussion

This chapter has taken a tour of characterizations for standard notions of behavioral preorder and equivalence on transition systems such as trace equivalence and bisimilarity.

In particular, in constructing the relationships of @fig-equivalence-big-picture for bisimilarity, we have collected the theoretical ingredients for a *certifying algorithm* to check bisimilarity of states.

::: {#fig-game-algo-overview fig-pos='t' fig-env="figure*"}
```tikz
\begin{tikzpicture}[auto,node distance=2.7cm,
  algstep/.style={minimum width=2.5cm, minimum height=1.2cm, draw=gray, rectangle,align=center,rounded corners}]
  \node[algstep] (TS) {$p$ and $q$ in\\ system $\system$};
  \node[algstep, below of=TS, node distance=7.8cm] (BisimGame) {Bisimulation \\ game ${{\game}^{\system}_{\notionname{B}}}$};
  \node[algstep, right of=BisimGame, node distance=7cm] (WinningRegion) {Winning regions\\$\attackerwins^{{\game}^{\system}_{\notionname{B}}}$ and $\defenderwins^{{\game}^{\system}_{\notionname{B}}}$};
  \node[draw, diamond, above of=WinningRegion, node distance=2cm, minimum width=.8cm, minimum height=.8cm] (Decision) {};
  \node[algstep, above left of=Decision] (Relation) {Bisimulation \\ relation $\rel{R}_s$};
  \node[algstep, above right of=Decision] (Formula) {Distinguishing \\ formula $\varphi_s$};
  \node[algstep, above of=WinningRegion, node distance=7.8cm] (Output) {Yes / No};
  \node[above of=Relation, node distance=2.5cm] (Yes) {Certifiably yes $✔$};
  \node[above of=Formula, node distance=2.5cm] (No) {$✗$ Certifiably no};
  \path
    (TS) edge[->, swap] node {Def.~2.20} (BisimGame)
    (TS) edge[->, dashed] node {Bisimilar?} (Output)
    (BisimGame) edge[->] node {Alg.~2.1} (WinningRegion)
    (WinningRegion) edge[->, swap] node {$[p,q] \in \defenderwins^{{\game}^{\system}_{\notionname{B}}}$} (Decision)
    (Decision) edge[->] node {Yes: Thm.~2.2\vphantom{p}} (Relation)
    (Decision) edge[->, swap] node {No: Lem.~2.10\vphantom{p}} (Formula)
    (Relation) edge[->] node[align=right] {Check relation fulfills \\ bisimulation Def.~2.6\vphantom{p}} (Yes)
    (Formula) edge[->, swap] node[align=left] {Check distinction using \\ HML game Def~2.19 + Alg.~2.1\vphantom{p}} (No);
  \draw
    (Output.south) |- (Yes.east)
    (Output.south) |- (No.west);
\end{tikzpicture}
```

Checking bisimilarity and providing certificates.
:::

@fig-game-algo-overview describes how to not only answer the question whether two states $p$ and $q$ are bisimilar, but how to also either provide a bisimulation relation or a distinguishing formula for the two as certificates for the answer.
(The arrows stand for computations, the boxes for data.)

In this view, the game of possible distinctions and their preventability between attacker and defender serves as the “ground truth” about the bisimilarity of two states.
Bisimulation relations and modal formulas only appear as witnesses of defender and attacker strategies, mediating between game and transition system.
The Hennessy--Milner theorem emerges on this level as a shadow of the determinacy of the bisimulation game (@nte-idea-games).
This whole framework draws heavily from @stirling1996modal.

We have disregarded the topic of axiomatic characterizations for behavioral equivalences.
In these, sets of equations on process algebra terms (such as $\ccs$) define behavioral congruences.
Thus, they tend to be coupled to specific process languages and lack the genericity we pursue in starting out from transition systems.

We have observed that behavioral equivalences can be arranged in hierarchies and that these hierarchies could be handled nicely using modal characterizations to rank distinguishing powers (Subsection [-@sec-perks-modal-characterizations]).
We have also seen how to link game rules to productions in a language of potentially distinguishing formulas (Subsection [-@sec-bisim-game-hml]).
This departs from common textbook presentations that motivate the bisimulation game through the relational (coinductive) characterization [e.g. @sangiorgi2012].
In later chapters, we will rather derive equivalence games from grammars of modal formulas (@nte-idea-modal-first), to generalize the framework of @fig-game-algo-overview for whole spectra of equivalences.

But first, we have to make formal what we mean by *equivalence spectra*.

