---
title: "Preliminaries: Communicating Systems and Games"
---

{{< include style/macros.md >}}

TODO: Preliminaries....

## Behavior of Programs

### Labeled Transition Systems

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.{{<isb locale Labeled_Transition_Systems lts>}}

We write $\derivatives{p, α}$ for the set $\set{p' \mid p \step α p'}$.
:::

{{<noindent>}} There is a canonical example used to discuss equivalences within transition systems.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#fig-henzinger .column-margin}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.
:::

::: {#exm-ts}
#### A Classic Example

  Consider the transition system $\system_\literal{PQ} = (\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}, \set{\literal a, \literal b, τ}, \step{\cdot}_\literal{PQ})$ given by the following graph:

::::{#fig-ts-determinism fig-pos=H}
  ```{mermaid}
  flowchart TD
    p0([P]) -- τ --> pA([p<sub>a</sub>])
    p0 -- τ --> pB([p<sub>b</sub>])
    pA -- a --> pA0([p<sub>1</sub>])
    pB -- b --> pB0([p<sub>2</sub>])

    q0([Q]) -- τ --> qAB([q<sub>ab</sub>])
    qAB -- a --> qA([q<sub>1</sub>])
    qAB -- b --> qB([q<sub>2</sub>])
  ```

  Example system $\system_\literal{PQ}$.
::::

  {{<noindent>}}
  The program described by the transitions from $\literal{P}$ choses non-deterministically during a $τ$-step between two options and then offers only either $\literal a$ *or* $\literal b$.
  The program $\literal{Q}$ on the other hand performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$ to the environment.
:::

{{<noindent>}} There are two things one might wonder about @exm-ts:

1. Should one care about non-determinism in programs? Subsection [-@sec-ccs] shows how non-determinism arises naturally in concurrent programs.
2. Should one consider $\literal P$ and $\literal Q$ equivalent? This heavily depends. Section [-@sec-behavioral-eq] will introduce a notion of equivalence under which the two are equivalent and one under which they differ.

::: {#rem-tau}
#### A Note on $τ$

The action $τ$ (the greek letter “tau”) will in later chapters stand for *internal behavior* and receive special treatment.
For the scope of this and the following three chapters, $τ$ is an action like every other.

Generally, this thesis aims to be consistent with notation and naming in surrounding literature.
But people who have been exposed to fewer compiler classes and semantics literature often find all the greek letters daunting.
So, where there are two options, we prefer the less-greek one.
After all, everything this thesis is about is simple, in a sense.
Also, we will usually write literals and constant names in $\textsf{sans-serif}$ and variables in $\textit{italics}$.
For the internal action, the whole field has converged to $τ$ in italics, however---so, we will run with this.
:::

### Calculus of Communicating Systems {#sec-ccs}

To talk about programs in this thesis, we will use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS).

::: {#def-ccs}
#### Calculus of Communicating Systems

  Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions ≔ \ccschannels \cup \set{ \coaction{α} \mid α ∈ \ccschannels } \cup \set{τ}$, are given by the following grammar:

  $$
  \begin{array}{cllr}
    P \grammardef
    & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“input action prefix”} \\
    & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“output action prefix”} \\
    & \ccsprefix{τ} P & &
        \text{“internal action”} \\
    & \ccsnull & &
        \text{“null process”} \\
    & X & \quad\text{with } X ∈ \ccsnames &
        \text{“recursion”} \\
    & P \ccschoice P & &
        \text{“choice”} \\
    & P \, \ccspar \, P & &
        \text{“parallel composition”} \\
    & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
        \text{“restriction”}
  \end{array}
  $$
  We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.
  The intuition is that an action $α$ represents receiving and $\coaction α$ expresses sending in communication.
  A pair of action and coaction can “react” in a communication situation and only become internal activity $τ$ in the view of the environment.

  Each sub-process tree must end in a $\ccsnull$-process or recursion.
  For brevity, we usually drop a final $\ccsnull$ when writing terms, e.g., just writing $\literal{ac}$ for $\ccsprefix{\literal{ac}} \ccsnull$.

  We place parenthesis, $(…)$, in terms where the syntax trees are otherwise ambiguous, but understand the choice operator $\ccschoice$ and the parallel operator $\ccspar$ to be associative.
:::

::: {#exm-ccs}
#### Concurrent Philosophers

  Following tradition, we will express our examples in terms of philosophers who need forks to eat spaghetti.^[
    Of course, you can just as well read the examples to be about computer programs that race for resources.]
  So, consider two philosophers $\literal{P_A}$ and $\literal{P_B}$ who want to grab a resource $\literal{fork}$ modeled as an action in order to eat where we express $\literal{P_A}$ eating with action $\literal{a}$ and $\literal{P_B}$ eating with $\literal{b}$.
  The philosopher processes read:

:::::: {.column-margin}
  ```{mermaid}
  flowchart TD
    p0([P<sub>A</sub>]) -- fork --> pA([a.0])
    pA -- a --> 0([<strong>0</strong>])
  ```
::::::

  $$
  \begin{gathered}
    \literal{P_A} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull \\
    \literal{P_B} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal b} \ccsnull
  \end{gathered}
  $$
  An LTS representation of $\literal{P_A}$'s behavior can be seen in the margin.
  Process $\literal P$ captures the whole scenario where the two philosophers compete for the fork using communication:
  $$
    \literal P ≔ ( \ccsprefix{\coaction{\literal{fork}}} \ccsnull \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  $$
  The restriction $… \ccsrestrict \set{\literal{fork}}$ expresses that the $\literal{fork}$-channel can only be used for communication within the system.

  As the $\coaction{\literal{fork}}$-action can be consumed by just one of the two philosophers, process $\literal P$ expresses exactly the program behavior seen in state $\literal P$ of @exm-ts.
:::

{{<noindent>}} The formal relationship between process terms and their LTS semantics is given by the following definition.

::: {#def-ccs-semantics}
#### CCS Semantics

Given an assignment of names to processes, $\ccsasg \colon \ccsnames → \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{α}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.
:::

{{< noindent >}} Feel free to go ahead an check that the transitions of @exm-ts indeed match those that @def-ccs-semantics prescribes for $\literal{P}$ of @exm-ccs!
(For readability, @exm-ts, has shorter state names, however.)
For instance, the transition $\literal P \step{τ} \literal{p_a}$ of @exm-ts would be justified as follows:

::: {.column-body-outset}
$$
\dfrac{
  \dfrac{
    \dfrac{
      \dfrac{
        \vphantom{\step{\coaction{\literal{fork}}}_\ccs}
      }{
        \coaction{\literal{fork}} \step{\coaction{\literal{fork}}}_\ccs \ccsnull
      }
      \quad
      \dfrac{
        \dfrac{
          \overline{
            \ccsprefix{\literal{fork}} \literal a
            \step{\literal{fork}}_\ccs
            \literal a
          }
          \qquad
          \ccsasg(\literal{P_A}) = \ccsprefix{\literal{fork}} \literal a
        }{
          \literal{P_A} \step{\literal{fork}}_\ccs \literal a
        }
      }{
        \literal{P_A} \ccspar \literal{P_B} \step{\literal{fork}}_\ccs \literal a \ccspar \literal{P_B}
      }
    }{
      \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B}
      \step{τ}_\ccs
      \ccsnull \ccspar \literal a \ccspar \literal{P_B}
    }
    \quad
    \begin{matrix}
      \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
      τ \notin \set{\literal{fork}}
    \end{matrix}
  }{
    ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
    \step{τ}_\ccs
    ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  }
  \quad
  \begin{matrix}
    \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
    \ccsasg(\literal P) = ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  \end{matrix}
}{
  \literal P \step{τ}_\ccs ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
}
$$
:::

{{< noindent >}} Non-determinism like in $\literal P$ of @exm-ts can be understood as a natural phenomenon in models with concurrency.
The model leaves unspecified which of two processes will consume an internal resource and, to the outsider, it is transparent which one took the resource until they communicate.
There are other ways how non-determinism plays a crucial role in models, for instance, as consequence of abstraction or parts that are left open in specifications.

The second process $\literal Q$ of @exm-ts can be understood as a deterministic sibling of $\literal P$.

::: {#exm-deterministic-phil}
#### Deterministic Philosophers

A process matching the transitions from $\literal Q$ in @exm-ts would be the following, where the philosophers take the fork as a team and then let the environment choose who of them eats:

$$
\literal Q ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
$$
:::

## Behavioral Equivalences {#sec-behavioral-eq}

### Trace Equivalence

::: {#def-traces}
#### Traces

The set of traces of a process $\traces{p}$ is recursively defined as

- $\emptyword ∈ \traces{p}$,^[We denote the empty word by $\emptyword$.]
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.{{<isb abbreviation Labeled_Transition_Systems lts.traces>}}

:::

::: {#def-trace-eq}
#### Trace Equivalence

Two processes $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.{{<isb abbreviation Strong_Equivalences lts.trace_equivalent>}}

Processes are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.{{<isb definition Strong_Equivalences lts.trace_preordered>}}
:::

::: {#exm-phil-traces}
The traces for the processes of @exm-ts would be $\traces{\literal{P}} = \set{\emptyword, τ, τ\literal{a}, τ\literal{b}} = \traces{\literal Q}$. Consequently, $\literal P$ and $\literal Q$ are trace-equivalent, $\literal P \beq{T} \literal Q$.

As $\traces{\literal{p_a}} = \set{\emptyword, \literal{a}} ⊆ \set{\emptyword, \literal{a}, \literal{b}} = \traces{\literal{q_{ab}}}$, $\literal{p_a}$ is trace-preordered to $\literal{q_{ab}}$, $\literal{p_a} \bpreord{T} \literal{q_{ab}}$.
This ordering is strict, that is, $\literal{q_{ab}} \nbpreord{T} \literal{p_a}$, due to $\literal{b} ∈ \traces{\literal{q_{ab}}}$ but $\literal{b} \notin \traces{\literal{p_a}}$.
We could say that trace $\literal{b}$ constitutes a *difference* between $\literal{q_{ab}}$ and $\literal{p_a}$.
:::

::: {#prp-trace-eq-rel}
The trace preorder $\bpreord{T}$ is indeed a preorder (i.e., transitive and reflexive) {{<isb lemma Strong_Equivalences lts.trace_preorder_transitive>}} and trace equivalence $\beq{T}$ is indeed an equivalence relation (i.e., transitive, reflexive, and moreover symmetric).{{<isb lemma Strong_Equivalences lts.trace_equivalence_equiv>}}
:::
::: proof
The properties carry over directly from $⊆$ and $=$ on sets of $\traces{\cdot}$.
:::

### Simulation and Bisimulation

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.{{<isb definition Strong_Equivalences lts.simulation>}}
:::

::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation-preorder, similarity and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.{{<isb definition Strong_Equivalences lts.simulated_by>}}
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.{{<isb abbreviation Strong_Equivalences lts.similar>}}
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.{{<isb definition Strong_Equivalences lts.bisimilar>}}
:::

::: {#exm-phil-sim}
The following relations are simulations on the LTS of @exm-ts:

- the empty relation $\rel R_\varnothing ≔ \varnothing$;
- the identity relation $\rel R_\mathrm{id} ≔ \identity{\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}} = \set{(\literal P, \literal P),\allowbreak (\literal{p_a}, \literal{p_a}),\allowbreak (\literal{p_b}, \literal{p_b}), (\literal{p_1}, \literal{p_1}),\allowbreak (\literal{p_2}, \literal{p_2}), (\literal Q, \literal Q), (\literal{q_{ab}}, \literal{q_{ab}}), \allowbreak(\literal{q_1}, \literal{q_1}), (\literal{q_2}, \literal{q_2})}$;
- the universal relation between all final states $\rel R_\mathrm{fin} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}}²$,
- more generally, the relation from final states to all other states: $\rel R_\mathrm{up} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}} × \states$;
- a minimal simulation for $\literal P$ and $\literal Q$: $\rel R_\literal{PQ} ≔ \set{(\literal{P}, \literal{Q}), (\literal{p_a}, \literal{q_{ab}}), (\literal{p_b}, \literal{q_{ab}}), (\literal{p_1}, \literal{q_1}), (\literal{p_2}, \literal{q_2})}$;
- and the combination of the above $\rel R_\mathrm{max} ≔ \rel R_\mathrm{sim} ∪ \rel R_\mathrm{id} ∪ \rel R_\mathrm{up}$.

{{<noindent>}} The simulation $\rel R_\literal{PQ}$ shows that $\literal P \bpreord{S} \literal Q$.

However, there is no simulation that preorders $\literal Q$ to $\literal P$, as there is no way to simulate the transition $\literal Q \step{τ} \literal{q_{ab}}$ from $\literal P$ for lack of a successor that allows $\literal a$ *and* $\literal b$ as does $\literal{q_{ab}}$.
(In @sec-hml, we will discuss how to capture such differences more formally.)

Thus, $\literal Q \nbpreord{S} \literal P$, and $\literal P \nbeq{S} \literal Q$. Moreover, there cannot be a symmetric simulation, $\literal P \nbeq{B} \literal Q$.
:::

::: {#prp-sim-eq-rel}
The simulation preorder $\bpreord{S}$ is indeed a preorder{{<isb lemma Strong_Equivalences lts.simulation_preorder_transitive>}}, and $\beq{S}$ and $\beq{B}$ are equivalences.{{<isb lemma Strong_Equivalences lts.bisimilarity_equiv>}}
:::
::: proof
1. Reflexivity of $\bpreord{S}$, $\beq{S}$ and $\beq{B}$:<br> $\identity{\states}$ is a (symmetric) simulation on each transition system.
2. Transitivity of $\bpreord{S}$:<br>
  If $\rel R_1$ and $\rel R_2$ are simulations, then the composition $\rel R_1 \rel R_2$ too is a simulation.
  This also establishes transitivity of $\beq{S}$.
  Moreover, that simulation $\rel R_1$ and $\rel R_2$ imply the composition $\rel R_1 \cup \rel R_2$ to be a simulation, allows to combine symmetric simulations to prove transitivity of $\beq{B}$.
3. Symmetry of $\beq{S}:$ By definition.
4. Symmetry of $\beq{B}$:<br>
  $p \beq{B} q$ implies there is a symmetric simulation $\rel R$ with $(p,q) ∈ \rel R$.
  As $\rel R = \inverse{\rel R}$, this implies $(q,p) ∈ \rel R$ and thus $q \beq{B} p$.
  \qedhere
:::

### The Hierarchy of Equivalences {#sec-hierarchy-equivalences}

Bisimilarity, similarity and trace equivalence form a small hierarchy of equivalences in the sense that they imply one-another in one direction, but not in the other.
Let us quickly make this formal:

:::: {#fig-core-hierarchy .column-margin}
```{mermaid}
  flowchart TD
    GI[Graph Isomorphism] -.-> B[Bisimilarity] --> S[Similarity] --> T[Trace Equivalence]
    style GI stroke-dasharray: 3 3
```

  Core hierarchy of equivalences.
::::



::: {#lem-bisim-bisim}
The relation $\beq{B}$ is itself a symmetric simulation.{{<isb lemma Strong_Equivalences lts.bisim_bisim>}}
:::

::: {#cor-bisim-impl-sim}
If $p \beq{B} q$, then $p \beq{S} q$.{{<isb lemma Strong_Equivalences lts.bisim_bisim>}}
:::

::: {#lem-sim-impl-traces}
If $p \bpreord{S} q$, then $p \bpreord{T} q$.{{<isb lemma Strong_Equivalences lts.sim_implies_trace_preord>}}
(Consequently, $p \beq{S} q$ also implies $p \beq{T} q$.{{<isb lemma Strong_Equivalences lts.sim_eq_implies_trace_eq>}})
:::

{{<noindent>}} We also have seen with example @exm-phil-sim that this hierarchy is strict between trace and simulation preorder in the sense that there exist $p,q$ with $p \bpreord{T} q$ but not $p \bpreord{S} q$.
The hierarchy also is strict between similarity and bisimilarity as the following example shows.

::: {#exm-bisim-sim}
#### Trolled philosophers

  Let us extend @exm-deterministic-phil with a troll process that might consume the $\literal{fork}$ and then do nothing:
  $$
  \literal {Q'} ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork} \ccspar \literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
  $$
  This adds another deadlock state to the transition system, seen in @fig-bisim-sim-ts.

:::: {#fig-bisim-sim-ts .column-margin}
  ```{mermaid}
  flowchart TD
    q0([Q']) -- τ --> qAB([q<sub>ab</sub>])
    qAB -- a --> qA([q<sub>1</sub>])
    qAB -- b --> qB([q<sub>2</sub>])
    q0 -- τ --> qT([q<sub>3</sub>])
  ```
  Example with new deadlock $\literal{q_3}$.
::::

  To similarity, this change is invisible, that is $\literal Q \beq{S} \literal{Q'}$.
  (Reason: The relation $\set{(\literal Q, \literal{Q'}), (\literal{Q'}, \literal{Q})} \cup \identity{\set{ \literal{q_{ab}}, \literal{q_1}, \literal{q_2}, \literal{q_3}}}$ is a simulation.)

  However, to bisimilarity, $\literal{Q'} \step{τ} \literal{q_3}$ constitutes a difference.
  There cannot be a symmetric simulation handling this transition as $\literal{Q}$ has no deadlocked successors.
  Thus $\literal Q \nbeq{B} \literal{Q'}$.
:::

The equivalences we have been discussed so far could also be understood as abstractions of an even finer equivalence, namely graph isomorphism:

::: {#def-graph-isomorphism}
#### Graph Isomorphism

A bijective function $\rel f \colon \states \to \states$ is called a *graph isomorphism* on a transition system if, for all $p,p', α$, the transition $p \step{α} p'$ exists if and only if the transition $\rel f(p) \step{α} \rel f(p')$ exists.{{<isb definition Strong_Equivalences lts.isomorphism>}}

Two states $p$ and $q$ are considered *graph-isomorphism-equivalent*, $p \beq{ISO} q$, iff there is a graph isomorphism $\rel f$ with $\rel f(p) = q$.{{<isb definition Strong_Equivalences lts.is_isomorphic_to>}}
:::

:::: {#exm-graph-isomorphism}
Consider the transition system in @fig-iso-ts. $\literal{p_{even}} \beq{ISO} \literal{p_{odd}}$ because $\rel f ≔ \set{\literal{p_{even}} \mapsto \literal{p_{odd}}, \literal{p_{odd}} \mapsto \literal{p_{even}}}$ is a graph isomorphism.

::: {#fig-iso-ts .column-margin}
```{mermaid}
flowchart TD
  pEven([p<sub>even</sub>]) -- τ --> pOdd([p<sub>odd</sub>]) -- τ --> pEven
```

Transition system with an isomorphic cycle.
:::
::::

::: {#lem-iso-impl-bisim}
The relation $\beq{ISO}$ is itself a symmetric simulation and thus $p \beq{ISO} q$ implies $p \beq{B} q$.{{<isb lemma Strong_Equivalences lts.iso_implies_bisim>}}
:::

Once again, the hierarchy is strict because of bisimilarity being less restricted in the matching of equivalent states.

::: {#exm-iso-vs-bisim}
Consider the processes $\literal{P_1} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $\literal{P_2} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$.
$\literal{P_1}$ can transition to $(\ccsnull \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$, while $\literal{P_2}$ has two options, namely $(\ccsnull \ccspar \ccsnull \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $(\ccsnull \ccspar \literal{fork} \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$. All three reachable processes are deadlocks and thus isomorphic.
But $\literal{P_1} \nbeq{ISO} \literal{P_2}$ because no bijection can connect the one successor of $\literal{P_1}$ and the two of $\literal{P_2}$.
However, $\literal{P_1} \beq{B} \literal{P_2}$, as bisimilarity is more relaxed.
:::

## Modal Logic {#sec-hml}

### Hennessy–Milner Logic to Express Observations

::: {#def-hml}
#### Hennessy–Milner Logic

Formulas of *Hennessy–Milner logic* $\hml$ are given by the grammar:{{<isb datatype Hennessy_Milner_Logic hml_formula>}}

$$
\begin{array}{rcllr}
  φ & \grammardef &
    \hmlobs{α}φ & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    & \grammaror & \hmland{i}{I}φ_i & \quad\text{with index set } I & \text{“conjunction”} \\
    & \grammaror & \hmlneg φ & & \text{“negation”} \\
\end{array}
$$
:::

{{<noindent>}} We also write conjunctions as sets $\hmlands \set{φ_1, φ_2…}$.
The empty conjunction $\hmlands \varnothing$ is denoted by $\hmltrue$ and serves as the nil-element of HML syntax trees.
We also usually omit them when writing down formulas, e.g., shortening $\hmlobs{\literal a}\hmlobs{\literal b}\hmltrue$ to $\hmlobs{\literal a}\hmlobs{\literal b}$.

The intuition behind HML is that it describes *what sequences of behavior* one may or may not *observe* of a system.
Observations $\hmlobs{α}…$ are used to build up possible action sequences;
conjunctions $\hmlands\set{…}$ capture branching points in decision trees;
and negations $\hmlneg …$ describe impossibilities.

::: {#def-hml-semantics}
#### HML semantics

The semantics of HML $\semantics{\cdot} \colon \hml → \powerset{\states}$ is defined recursively by:{{<isb primrec Hennessy_Milner_Logic lts.satisfies>}}

$$
\begin{array}{rcl}
  \semantics{\hmlobs{α}φ} & ≔ & \set{p \mid \exists p' ∈ \semantics{φ} \ldotp p \step α p'}\\
  \semantics{\hmland{i}{I}φ_i} & ≔ & \bigcap_{i ∈ I} \semantics{φ_i}\\
  \semantics{\hmlneg φ} & ≔ & \states \setminus \semantics{φ}
\end{array}
$$
:::

::: {#exm-hml}
Let us consider some observations on the system of @exm-ts.

- $\semantics{\hmlobs{τ}\hmlobs{\literal a}} = \set{\literal P, \literal Q}$ as both, $\literal P$ and $\literal Q$, expose the trace $τ\literal{a}$,
- $\literal Q ∈ \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$, but $\literal P \notin \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$.
- $\literal P ∈ \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$, but $\literal Q \notin \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$.
:::

### Characterizing Bisimilarity via HML

::: {#def-distinctions}
#### Distinctions and Equivalences

We say that formula $φ ∈ \hml$ *distinguishes* state $p$ *from* state $q$ if $p ∈ \semantics{φ}$ but $q \notin \semantics{φ}$.{{<isb abbreviation LTS_Semantics lts.distinguishes>}}

We say a sublogic $\observationsvar{} ⊆ \hml$ *preorders* state $p$ to $q$, $p \bpreordvar{\observationsvar{}} q$, if no $φ ∈ \observationsvar{}$ is distinguishing $p$ from $q$.{{<isb definition LTS_Semantics lts.preordered>}}
If the preordering goes in both directions, we say that $p$ and $q$ are equivalent with respect to sublogic $\observationsvar{}$, written $p \beqvar{\observationsvar{}} q$.{{<isb definition LTS_Semantics lts.equivalent>}}
:::

{{<noindent>}} By this account, $\hmlobs{τ}\hmlneg\hmlobs{\literal a}$ of @exm-hml distinguishes $\literal P$ from $\literal Q$.
$\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}$, on the other hand, distinguishes $\literal Q$ from $\literal P$.
(The direction matters!)
For instance, the sublogic $\set{\hmlobs{τ}\hmlobs{\literal a}, \hmlobs{τ}\hmlobs{\literal b}}$ preorders $\literal P$ and $\literal Q$ in both directions; so the two states are equivalent with respect to this logic.


::: {#prp-hml-eq}
Consider an arbitrary HML sublogic $\observationsvar{} ⊆ \hml$.
Then, $\bpreordvar{\observationsvar{}}$ is a preorder, and $\beqvar{\observationsvar{}}$ an equivalence relation.{{<isb lemma LTS_Semantics lts.equivalent_equiv>}}
:::

::: {#lem-hml-eq-sim}
Hennessy–Milner logic equivalence $\beqvar{\hml}$ is a simulation relation.{{<isb lemma HML_Spectrum lts.hml_equiv_sim>}}
:::

::: proof
Assume it were not.
Then there would need to be $p \beqvar{\hml} q$ with step $p \step α p'$, and no $q'$ such that $q \step α q'$ and $p' \beqvar{\hml} q'$.
So there would need to be a distinguishing formula $φ_{q'}$ for each $q'$ that $q$ can reach by an $α$-step.
Consider the formula $φ_α ≔ \hmlobs{α}\hmland{q'}{\set{q' \mid q \step α q'}} φ_{q'}$.
It must be true for $p$ and false for $q$, contradicting $p \beqvar{\hml} q$.
:::

::: {#lem-hml-eq-bisim-invariant}
#### HML Bisimulation Invariance

If $p ∈ \semantics{φ}$ and $p \beq{B} q$ then $q ∈ \semantics{φ}$.{{<isb lemma HML_Spectrum lts.hml_bisim_invariant>}}
:::

::: proof
Induct over the structure of $φ$ with arbitrary $p$ and $q$.

- Case $p ∈ \semantics{\hmlobs{α}φ}$.
  Thus there is $p' ∈ \semantics{φ}$ with $p \step α p'$.
  Because $\beq{B}$ is a simulation according to @lem-bisim-bisim, this implies $q'$ with $p' \beq{B} q'$.
  The induction hypothesis makes $p' ∈ \semantics{φ}$ entail $q' ∈ \semantics{φ}$
  and thus $q ∈ \semantics{\hmlobs{α}φ}$.
- Case $p ∈ \semantics{\hmland{i}{I}φ_i}$.
  The induction hypothesis on the $φ_i$ directly leads to
  $q ∈ \semantics{\hmland{i}{I}φ_i}$.
- Case $p ∈ \semantics{\hmlneg φ}$.
  Symmetry of $\beq{B}$ accoding to @prp-sim-eq-rel, implies $q \beq{B} p$.
  By induction hypothesis, $q ∈ \semantics{φ}$ implies $p ∈ \semantics{φ}$.
  So, using contraposition, the case implies $q ∈ \semantics{\hmlneg φ}$.\qedhere
:::

{{<noindent>}}Combining the bisimulation invariance for one direction and that $\beq{\hml}$ is symmetric (@prp-hml-eq) simulation (@lem-hml-eq-sim) for the other, we obtain that $\hml$ precisely characterizes bisimilarity:

::: {#thm-hennessy-milner}
#### Hennessy–Milner Theorem

Bisimilarity and HML equivalence coincide, that is, $p \beq{B} q$ precisely if $p \beq{\hml} q$.{{<isb theorem HML_Spectrum lts.Hennessy_Milner_theorem>}}
:::

::: {#rem-image-finiteness}
In the standard presentation of the theorem, image finiteness of the transition system is assumed.
This means that $p \step α \cdot$ is finite for every $p ∈ \states$.
The amount of outgoing transitions matters precisely in the construction of $φ_α$ in the proof of @lem-hml-eq-sim.
But as our definition of $\hml$ (@def-hml) allows infinite conjunctions $\hmland{i}{I} …$, we do not need an assumption here.
The implicit assumption is that the cardinality of index sets $I$ can match that of $p \step α \cdot$.
The original proof by @hm1980hml uses binary conjunction and thus can only express finitary conjunctions.
:::

### The Perks of Modal Characterizations

There is merit in also characterizing other equivalences through sublogics $\observationsvar{} \subseteq \hml$.
There are three immediate big advantages to modal characterization:

Modal characterizations lead to *proper preorders and equivalences by design* due to @prp-hml-eq.
That is, if a behavioral preorder (or equivalence) is defined through modal logics, there is no need of proving transitivity and reflexivity (and symmetry).

Secondly, modal characterizations can directly *unveil the hierarchy between preorders*, if defined cleverly, because of the following property.

::: {#prp-difference-contraposition}
If $\observationsvar{} \subseteq \observationsvar{}'$ then $p \bpreordvar{\observationsvar{}'} q$ implies $p \bpreordvar{\observationsvar{}} q$ for all $p,q$.{{<isb lemma LTS_Semantics lts_semantics.preorder_contraposition>}}
:::

Pay attention to the opposing directions of $\subseteq$ and implication, here!

Thirdly, as a corollary of @prp-difference-contraposition, modal characterizations *ensure equivalences to be refinements of bisimilarity*, which is a sensible base notion of equivalence.
<!-- TODO: add forwards pointer on good complexities of bisimilarity -->

In Chapter [-@sec-spectrum], we will discuss how the hierarchy of behavioral equivalences can be understood nicely and uniformly if viewed through the modal lense.

### Expressiveness and Distinctiveness

@prp-difference-contraposition actually is a weak version of another proposition about *distinctiveness* of logics.

::: {#def-leq-expressive}
We say that an $\actions$-observation language $\observationsvar{}$ is *less or equal in expressiveness* to another $\observationsvar{}'$ iff, for any $\actions$-transition system, for each $φ ∈ \observationsvar{}$, there is $φ' ∈ \observationsvar{}'$ such that $\semantics{φ} = \semantics{φ'}$.
(The definition can also be read with regards to a fixed transition system $\system$.){{<isb definition LTS_Semantics lts_semantics.leq_expressive>}}
If the inclusion holds in both directions, $\observationsvar{}$ and $\observationsvar{}'$ are *equally expressive*.
:::

::: {#def-leq-distincitve}
We say that an $\actions$-observation language $\observationsvar{}$ is *less or equal in distintiveness* to another $\observationsvar{}'$ iff, for any $\actions$-transition system and states $p$ and $q$, for each $φ ∈ \observationsvar{}$ that distinguishes $p$ from $q$, there is $φ' ∈ \observationsvar{}'$ that distinguishes $p$ from $q$.{{<isb definition LTS_Semantics lts_semantics.leq_distintive>}}
If the inclusion holds in both directions, $\observationsvar{}$ and $\observationsvar{}'$ are *equally distinctive*.
:::

::: {#lem-subset-expressiveness-distinctiveness}

Subset relationship entails expressiveness entails distinctiveness.

- If $\observationsvar{} ⊆ \observationsvar{}'$, then $\observationsvar{}$ is less or equal in expressiveness to $\observationsvar{}'$.{{<isb lemma LTS_Semantics lts_semantics.subset_expressiveness>}}
- If $\observationsvar{}$ is less or equal in expressiveness to $\observationsvar{}'$, then $\observationsvar{}$ is less or equal in distinctiveness to $\observationsvar{}'$.{{<isb lemma LTS_Semantics lts_semantics.expressiveness_entails_distinctiveness>}}
:::

The other direction does not hold.
For instance, $\hml ⊈ \hml \setminus \set{\hmltrue}$, but they are equally expressive as $\hmlneg\hmlneg\hmltrue$ can cover for the removed element.
At the same time, $\set{\hmltrue}$ is more expressive than $\varnothing$, but equally distinctive.

The stronger version of @prp-difference-contraposition is thus:

::: {#prp-distinctiveness-contraposition}
If $\observationsvar{}$ is less or equal *in distinctiveness* to $\observationsvar{}'$ then $p \bpreordvar{\observationsvar{}'} q$ implies $p \bpreordvar{\observationsvar{}} q$ for all $p,q$.{{<isb lemma LTS_Semantics lts_semantics.preorder_expressiveness_contraposition>}}
:::

Often, an equivalence may be characterized by different sublogics.
In particular, one may find smaller characterizations as in the following example for bisimilarity.

::: {#exm-game-formulas}

Consider $\observations{\floor{B}} \subseteq \hml$ described by the following grammar.

$$
\begin{array}{rcll}
  φ^\mathrm{\floor{B}}
    & \grammardef & \hmlobs{α} \hmland{i}{I} φ^\mathrm{\floor{B}}_i \\
    & \grammaror  & \hmlneg φ^\mathrm{\floor{B}}
\end{array}
$$
:::

{{<noindent>}} $\observations{\floor{B}}$ is a proper subset of $\hml$.
For instance, it lacks the observation $\hmlobs{\literal a} \hmlobs{\literal b} \hmltrue$.
Due to the subset relation, $\observations{\floor{B}}$ must be less or equal in expressiveness to $\hml$, but this inclusion too is strict as $\hmltrue$ cannot be covered for.
But it is equally distinctive!

::: {#lem-game-formula-hml}
$\observations{\floor{B}}$ and $\hml$ are equally distinctive.{{<isb theorem HML_Spectrum lts.hml_and_bisimulation_game_observations_equally_expressive>}}
:::
::: proof

One direction is immediate from @lem-subset-expressiveness-distinctiveness as $\observations{\floor{B}} \subseteq \hml$.

For the other direction, we need to establish that for each $φ ∈ \hml$ distinguishing some $p$ from some $q$, there is a $φ' ∈ \observations{\floor{B}}$ distinguishing $p$ from $q$.
We induct on the structure of $φ$ with arbitrary $p$ and $q$.

- Case $\hmlobs{α}φ$ distinguishes $p$ from $q$.
  Thus there is $p'$ with $p \step α p'$ distinguishing $p'$ from all $q' ∈ \derivatives{q, α}$.
  By induction hypothesis, there must be $φ'_{q'} ∈ \observations{\floor{B}}$ distinguishing $p'$ from $q'$ for each $q'$.
  Thus $\hmlobs{α}\hmland{q'}{\derivatives{q, α}} φ'_{q'} ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.
- Case $\hmland{i}{I}φ_i$ distinguishes $p$ from $q$.
  Therefore some $φ_i$ already distinguishes $p$ from $q$.
  By induction hypothesis, there must be $φ'_i ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.
- Case $\hmlneg φ$ distinguishes $p$ from $q$.
  Thus $φ$ distinguishes $q$ from $p$.
  By induction hypothesis, there is $φ' ∈ \observations{\floor{B}}$ distinguishing $q$ from $p$.
  Accordingly, $\hmlneg φ' ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$.\qedhere
:::

## Games {#sec-games}

So far, we have only seen behavioral equivalences and modal formulas as mathematical objects.
This section introduces *game-theoretic characterizations* as a way of easily providing decision procedures for equivalences and logics alike.

```{mermaid}
flowchart TD
  bisim["<span class='katex'><span class='mathnormal'>p</span> ~<sub>B</sub> <span class='mathnormal'>q</span>"] x--o|"Hennessy–Milner theorem"| distinction["<span class='katex'>There is <span class='mathnormal'>φ</span> distinguishing <span class='mathnormal'>p</span> from <span class='mathnormal'>q</span>.</span>"]
  bisim <-->|Strling's characterization| defWins["<span class='katex'>Defender wins bisimulation game from [<span class='mathnormal'>p, q</span>].</span>"] x--o|Determinacy of Games| attWins["<span class='katex'>Attacker wins bisimulation game from [<span class='mathnormal'>p, q</span>].</span>"]
  distinction <-->|Section 4.4| attWins
```

### Reachability Games

*Gale--Stewart-style reachability games* where the defender wins all infinite plays.

::: {#def-game}
#### Reachability Game

A *reachability game* $\game = (G, G_\defender, \gamemoveblank)$ is played on a directed graph consisting of

- a set of *game positions* $G$, partitioned into
  - *defender positions* $G_\defender ⊆ G$
  - and *attacker positions* $G_\attacker ≔ G \setminus G_\defender$,
- and a set of *game moves* ${\gamemoveblank} ⊆ G × G$.{{<isb locale Equivalence_Games game>}}

{{<noindent>}} We denote by $\game[g_0]$ the game played from starting position $g_0 ∈ G$.
:::

::: {#def-game-plays}
#### Plays and Wins

We call the paths ${g_0}{g_1} … ∈ G^{\infty}$ with $g_{i} \gamemoveblank g_{i+1}$ *plays* of $\game[g_0]$.
They may be finite or infinite.
The defender *wins* infinite plays.
If a finite play $g_{0}\dots g_{n}\!\ngamemoveblank$ is stuck, the stuck player loses: The defender wins if $g_{n} ∈ G_\attacker$, and the attacker wins if $g_{n}∈ G_\defender$.
:::

::: {#def-strategies}
#### Strategies and Winning Strategies

A (positional, non-deterministic) *attacker strategy* is a subset of the moves starting in attacker states, $\rel F ⊆ (G_\attacker × G) \cap \mathord{\gamemoveblank}$.

Similarly, a *defender strategy* is a subset of the moves starting in defender states, $\rel F ⊆ (G_\defender × G) \cap \mathord{\gamemoveblank}$.
If (fairly) picking elements of strategy $\rel F$ ensures a player to win, $\rel F$ is called a *winning strategy* for this player.
The player with a winning strategy for $\game[g_{0}]$ is said to *win* $\game[g_{0}]$.
If $\rel F$ is a function on $G_\attacker$ or $G_\defender$, respectively, we call it a *deterministic* strategy.

:::

{{<noindent>}} This kind of games essentially is a subclass of parity games only colored by 0.
So the games are positionally determined.
This means, for each possible initial position, exactly one of the two players has a positional deterministic winning strategy $\rel F$.
We call this partitioning of the game positions the winning regions.

::: {#def-winning-region}
#### Winning Region

The set $\attackerwins ⊆ G$ of all positions $g$ where the attacker wins $\game[g]$ is called the *attacker winning region* of $\game$.
The defender winning region $\defenderwins$ is defined analogously.
:::

::: {#exm-formula-game}
#### A Simple Choice

Consider the game in @fig-game-ex, where round nodes represent defender positions and rectangular ones attacker positions.
Its valid plays starting from $(\literal{1})$ are
$(\literal{1})$,
$(\literal{1})[\literal{2a}]$,
$(\literal{1})[\literal{2b}]$, and
$(\literal{1})[\literal{2a}](\literal{3})$.
The defender can win from $(\literal{1})$ with a strategy moving to $[\literal{2b}]$ where the attacker is stuck.
Moving to $[\literal{2a}]$ instead would get the defender stuck.
So, the defender winning region is $\defenderwins = \set{(\literal{1}),[\literal{2b}]}$ and the attacker wins $\attackerwins = \set{[\literal{2a}], (\literal{3})}$.

:::: {#fig-game-ex .column-margin}
  ```{mermaid}
  flowchart TD
    1([1]) --> 2a[2a] --> 3([3])
    1 --> 2b[2b]
  ```
  A simple game.
::::
:::

::: {#prp-determinacy}
#### Determinacy

Reachability games are (positionally) determined, that is,
for any game, each game position has exactly one winner:
$G = \attackerwins \cup \defenderwins$ and $\attackerwins \cap \defenderwins = \varnothing$.
:::
TODO: Provide soooome proof

::: {#alg-deciding-games}

TODO

Deciding reachability games.
:::

### The Semantic Game of HML

::: {#def-hml-game}
#### HML Game

For a transition system $\system = (\states,\actions,\step{})$,
the $\hml$ *game* ${\game}_\hml^{\system} = (G_\hml,G_\defender,\gamemoveblank_\hml)$ is played on $G_\hml = \states × \hml$,
where the defender controls observations and negated conjunctions,
that is $(p, \hmlobs{α}φ) ∈ G_\defender$ and
$(p,\hmlneg\hmland{i}{I}φ_i) ∈ G_\defender$ (for all $φ,p,I$), and the attacker controls the rest.

- The defender can perform the moves:
  $$
  \begin{array}{rclr}
      (p, \hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
      (p, \hmlneg{\hmland{i}{I}φ_i})
      & \gamemoveblank_\hml
      & (p, \hmlneg φ_i)
      & \text{ with $i ∈ I$;}
  \end{array}
  $$
- and the attacker can move:
  $$
  \begin{array}{rclr}
    (p, \hmlneg\hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', \hmlneg φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
    (p, \hmland{i}{I}φ_i)
      & \gamemoveblank_\hml
      & (p, φ_i)
      & \text{ with $i ∈ I \quad$ and} \\
    (p, \hmlneg\hmlneg φ)
      & \gamemoveblank_\hml
      & (p, φ).
      &
  \end{array}
  $$
:::

::: {#exm-formula-game-cont}

@exm-formula-game is exactly the HML game ${\game}_\hml^{\system_\literal{PQ}}$ for formula $\hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue$ and state $\literal P$ of @exm-hml with
$(\literal{1}) ≔ (\literal{P}, \hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2a}] ≔ (\literal{p_a}, \hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2b}] ≔ (\literal{p_b}, \hmlneg\hmlobs{\literal a}\hmltrue)$, and
$(\literal{3}) ≔ (\literal{p_1}, \hmlneg\hmltrue)$.
:::

::: {#lem-hml-semantic-game}
The defender wins ${\game}_\hml^{\system}[(p, φ)]$ precisely if $p ∈ \semantics{φ}$.
:::

### The Bisimulation Game

::: {#def-bisim-game}
#### Bisimulation Game

For a transition system $\system$, the *bisimulation game* ${\game}_\notionname{B}^{\system}${{<isb locale Equivalence_Games bisim_game>}} is played on
attack positions $G^\notionname{B}_\attacker ≔ \states × \states$ and defense positions $G^\notionname{B}_\defender ≔ \actions × \states × \states$ with the following moves:

- The attacker may *swap sides*
  $$[p, q] \quad \gamemoveblank_\notionname{B} \quad [q, p],$$
- or *challenge simulation*
  $$[p, q] \quad \gamemoveblank_\notionname{B} \quad (α, p', q) \quad \text{if} \quad p \step{α} p';$$
- and the defender *answers simulation challenges*
  $$(α, p', q) \quad \gamemoveblank_\notionname{B} \quad (p', q') \quad \text{if} \quad q \step{α} q'.$$
:::

::: {#exm-bisim-game}
Consider $\literal{p_{even}} \beq{B} \literal{p_{odd}}$ of @exm-graph-isomorphism.
The bisimulation game on this system is given by @fig-bisim-game-even-odd:

:::: {#fig-bisim-game-even-odd}
  ```{mermaid}
  flowchart TD
    eo["p<sub>even</sub>, p<sub>odd</sub>"] -->|challenge| too(["τ, p<sub>odd</sub>, p<sub>odd</sub>"]) -->|answer| oe["p<sub>odd</sub>, p<sub>even</sub>"] -->|challenge| tee(["τ, p<sub>even</sub>, p<sub>even</sub>"]) -->|answer| eo -->|swap| oe -->|swap| eo
  ```
  Bisimulation game under $\literal{p_{even}}, \literal{p_{odd}}$.
  Moves are annotated with the game rules from which they derive.
::::

Clearly, there is no way for the attacker to get the defender stuck.
Whatever strategy the attacker choses, the game will go on forever, leading to a win for the defender.
That it is always safe for the defender to *answer* with moves to $[\literal{p_{even}}, \literal{p_{odd}}]$ and $[\literal{p_{odd}}, \literal{p_{even}}]$ corresponds to $\rel R ≔ \set{(\literal{p_{even}}, \literal{p_{odd}}), (\literal{p_{odd}}, \literal{p_{even}})}$ being a bisimulation.
:::


::: {#exm-bisim-sim-game}
Let us recall @exm-bisim-sim of the “trolled philosophers,” where we determined $\literal{Q}$ and $\literal{Q'}$ to be non-bisimilar.
The bisimulation game graph for the system is depicted in @fig-bisim-sim-game.

The attacker can win by moving $[\literal{Q}, \literal{Q'}]
\gamemoveblank_\notionname{B} [\literal{Q'}, \literal{Q}]
\gamemoveblank_\notionname{B} (\tau, \literal{q_3}, \literal{Q})
\gamemoveblank_\notionname{B} [\literal{q_3}, \literal{q_{AB}}]
\gamemoveblank_\notionname{B} [\literal{q_{AB}}, \literal{q_3}]
\gamemoveblank_\notionname{B} (\literal{a}, \literal{q_1}, \literal{q_3})
\ngamemoveblank_\notionname{B}$.
Along this sequence of positions, the defender never has a choice and is stuck in the end.
The attacker exploits, that $\literal{Q'}$ can reach an early deadlock via $\literal{Q'} \step{\tau} \literal{q_{3}}$.
:::

::: {#fig-bisim-sim-game}
```tikz

\begin{adjustbox}{max width=\textwidth, center}
  \begin{tikzpicture}[>->, shorten <=1pt, shorten >=0.5pt, auto, node distance=2cm,
    posStyle/.style={draw, inner sep=1ex, minimum size=1cm, minimum width=2.25cm, anchor=center, draw, black, fill=gray!5},
    defender/.style={ellipse, inner sep=0ex},
    defWins/.style={fill=blue!5}]

    \node[posStyle, initial, initial text={}]
      (Att_Q_Qp){$[\literal{Q}, \literal{Q'}]$};
    \node[posStyle]
      (Att_Qp_Q) [below = 2cm of Att_Q_Qp] {$[\literal{Q'}, \literal{Q}]$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Qp) [right = 1.5cm of Att_Q_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q'})$};
    \node[posStyle, defWins]
      (Att_qab_qab) [below right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_{AB}}]$};
    \node[posStyle]
      (Att_qab_q3) [above right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_3}]$};
    \node[posStyle, defender]
      (Dfn_a_q1_q3) [above right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{a}, \literal{q_1}, \literal{q_3})$};
    \node[posStyle, defender]
      (Dfn_b_q2_q3) [below right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{b}, \literal{q_2}, \literal{q_3})$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Q) [below = 1cm of Dfn_t_qab_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q})$};
    \node[posStyle, defender]
      (Dfn_t_q3_Q) [below = 1cm of Dfn_t_qab_Q] {$(\tau, \literal{q_{3}}, \literal{Q})$};
    \node[posStyle]
      (Att_q3_qab) [below = 1cm of Att_qab_qab] {$[\literal{q_3}, \literal{q_{AB}}]$};

    \path
      (Att_Q_Qp)
        edge[bend left = 10] node {swap} (Att_Qp_Q)
        edge node {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Dfn_t_qab_Qp)
      (Att_qab_q3)
        edge[bend left = 65] node {swap} (Att_q3_qab)
      (Att_q3_qab)
        edge[bend right = 60] node {} (Att_qab_q3)
      (Dfn_t_qab_Qp)
        edge node {$\literal{Q'} \step{\tau} \literal{q_{3}}$} (Att_qab_q3)
        edge node {$\literal{Q'} \step{\tau} \literal{q_{AB}}$} (Att_qab_qab)
      (Att_qab_qab)
        edge [loop left] node {swap} ()
      (Att_Qp_Q)
        edge[bend left = 10] node {swap} (Att_Q_Qp)
        edge[swap] node {$\literal{Q'} \step{\tau} \literal{q_{AB}}$} (Dfn_t_qab_Q)
        edge[swap] node {$\literal{Q'} \step{\tau} \literal{q_{3}}$} (Dfn_t_q3_Q)
      (Dfn_t_qab_Q)
        edge node[swap] {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Att_qab_qab)
      (Dfn_t_q3_Q)
        edge node[swap] {$\literal{Q} \step{\tau} \literal{q_{AB}}$} (Att_q3_qab)
      (Att_qab_q3)
        edge node {$\literal{q_{AB}} \step{\literal{a}} \literal{q_1}$} (Dfn_a_q1_q3)
        edge node {$\literal{q_{AB}} \step{\literal{b}} \literal{q_2}$} (Dfn_b_q2_q3)
    ;
  \end{tikzpicture}
\end{adjustbox}
```

Bisimulation game on non-bisimilar states $\literal{Q}$ and $\literal{Q'}$ of @exm-bisim-sim-game.
Moves are labeled by their justification.
Defender-won positions are tinted blue.
:::

::: {#thm-bisim-game-characterization}
#### Stirling's Game Characteirzation

The defender wins the bisimulation game ${\game}_\notionname{B}^{\system}$ starting at attacker position $[p, q]$ precisely if $p \beq{B} q$.{{<isb theorem Equivalence_Games bisim_game.bisim_game_characterization>}}
:::
::: proof
Sketch for both directions:

- If $\rel R$ is a symmetric simulation with $(p,q) ∈ \rel R$,
  then the following positional defender strategy is well-defined and winning from $[p, q]$:{{<isb lemma Equivalence_Games bisim_game.bisim_implies_defender_winning_strategy>}}
  $$\rel f (α, p', q) ≔ [p', \operatorname{choose} q'\ldotp (p', q') ∈ \rel R \land q \step{α} q'].$$
- If there is a positional defender strategy $\rel f$ winning from $[p, q]$,
  then the following relation $\rel R$ with $(p_0,q_0) ∈ \rel R$ is a symmetric simulation:{{<isb lemma Equivalence_Games bisim_game.defender_winning_strategy_implies_bisim>}}
  $$\rel R ≔ \set{(p,q) \mid \text{there is a play $(p_0, q_0),...,(p,q)$ following strategy $\rel f$}}.$$
:::

### How Bisimulation Game and HML Are Connected {#sec-bisim-game-hml}

Let us pause to think how bisimulation game and Hennessy–Milner logic connect.

You might have wondered why we even need a dedicated bisimulation game.
The Hennessy–Milner theorem implies that we could directly use the HML game of @def-hml-game to decide bisimilarity:

::: {#def-naive-bisim-game}

#### Naive Bisimulation Game

We extend the @def-hml-game by the following prefix:

1. To challenge $[p,q]$, the attacker picks a formula $φ ∈ \hml$ (claiming that $φ$ distinguishes the states) and yields to the defender $(φ, p, q)$.
2. The defender decides where to start the HML game:
    1. Either at $(p, \hmlneg φ)$ (claiming $φ$ to be non-distinguishing because it is untrue for $p$)
    2. or at $(q, φ)$ (claiming $φ$ to be non-distinguishing because it is true for $q$).
3. After that the turns proceed as prescribed by @def-hml-game.

:::

{{<noindent>}} This naive game, too, has the property that the defender wins from $[p,q]$ iff $p \beq{B} q$.
The downside of the game is that the attacker has infinitely many options $φ ∈ \hml$ to pick from!

The proper bisimulation game of @def-bisim-game, on the other hand, is *finite for finite transition systems*.
Therefore, it induces decision procedures.

We will now argue that the *bisimulation game actually is a variant of the naive game*, where (1) the attacker names their formula *gradually*, and (2) the formulas stem from $\observations{\floor{B}} \subseteq \hml$ of @exm-game-formulas.
To this end, we will show that attacker's winning strategies imply distinguishing formulas, and that a distinguishing formula from $\observations{\floor{B}}$ certifies the existence of winning attacker strategies.

::: {#exm-bisim-sim-game-formulas}

Let us illustrate how to derive distinguishing formulas using the game of @exm-bisim-sim-game.

Recall that the attacker wins by moving $[\literal{Q}, \literal{Q'}]
\gamemoveblank_\notionname{B} [\literal{Q'}, \literal{Q}]
\gamemoveblank_\notionname{B} (\tau, \literal{q_3}, \literal{Q})
\gamemoveblank_\notionname{B} [\literal{q_3}, \literal{q_{AB}}]
\gamemoveblank_\notionname{B} [\literal{q_{AB}}, \literal{q_3}]
\gamemoveblank_\notionname{B} (\literal{a}, \literal{q_1}, \literal{q_3})
\ngamemoveblank_\notionname{B}$.
In @fig-bisim-sim-game-formulas, we label the game nodes with the (sub-)formulas this strategy corresponds to.
Swap moves become negations, and simulation moves become observations with a conjunction of formulas for each defender option.
This attacker strategy can thus be expressed by $\hmlneg\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue} \in \observations{\floor{B}}$.
:::

::: {#fig-bisim-sim-game-formulas}
```tikz

\begin{adjustbox}{max width=\textwidth, center}
  \begin{tikzpicture}[>->, shorten <=1pt, shorten >=0.5pt, auto, node distance=2cm,
    posStyle/.style={draw, inner sep=1ex, minimum size=1cm, minimum width=2.25cm, anchor=center, draw, black, fill=gray!5},
    defender/.style={ellipse, inner sep=0ex},
    defWins/.style={fill=blue!5}]

    \node[posStyle, initial, initial text={}, label={100:$\hmlneg\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue}$}]
      (Att_Q_Qp){$[\literal{Q}, \literal{Q'}]$};
    \node[posStyle, label={100:$\hmlobs{\tau}\hmlands\set{\hmlneg\hmlobs{\literal{a}}\hmltrue}$}]
      (Att_Qp_Q) [below = 2cm of Att_Q_Qp] {$[\literal{Q'}, \literal{Q}]$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Qp) [right = 1.5cm of Att_Q_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q'})$};
    \node[posStyle, defWins]
      (Att_qab_qab) [below right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_{AB}}]$};
    \node[posStyle, label={100:$\hmlobs{\literal{a}}\hmltrue$}]
      (Att_qab_q3) [above right = .1cm and 1.5cm of Dfn_t_qab_Qp] {$[\literal{q_{AB}}, \literal{q_3}]$};
    \node[posStyle, defender, above right = .1cm and 1.5cm of Att_qab_q3]
      (Dfn_a_q1_q3) {$(\literal{a}, \literal{q_1}, \literal{q_3})$};
    \node[posStyle, defender]
      (Dfn_b_q2_q3) [below right = .1cm and 1.5cm of Att_qab_q3] {$(\literal{b}, \literal{q_2}, \literal{q_3})$};
    \node[posStyle, defender, defWins]
      (Dfn_t_qab_Q) [below = 1cm of Dfn_t_qab_Qp] {$(\tau, \literal{q_{AB}}, \literal{Q})$};
    \node[posStyle, defender]
      (Dfn_t_q3_Q) [below = 1cm of Dfn_t_qab_Q] {$(\tau, \literal{q_{3}}, \literal{Q})$};
    \node[posStyle, label={100:$\hmlneg\hmlobs{\literal{a}}\hmltrue$}]
      (Att_q3_qab) [below = 1cm of Att_qab_qab] {$[\literal{q_3}, \literal{q_{AB}}]$};

    \path
      (Att_Q_Qp)
        edge[bend left = 10] node {} (Att_Qp_Q)
        edge node {} (Dfn_t_qab_Qp)
      (Att_qab_q3)
        edge[bend left = 65] node {} (Att_q3_qab)
      (Att_q3_qab)
        edge[bend right = 60] node {} (Att_qab_q3)
      (Dfn_t_qab_Qp)
        edge node {} (Att_qab_q3)
        edge node {} (Att_qab_qab)
      (Att_qab_qab)
        edge [loop left] node {} ()
      (Att_Qp_Q)
        edge[bend left = 10] node {} (Att_Q_Qp)
        edge node {} (Dfn_t_qab_Q)
        edge node {} (Dfn_t_q3_Q)
      (Dfn_t_qab_Q)
        edge node {} (Att_qab_qab)
      (Dfn_t_q3_Q)
        edge node {} (Att_q3_qab)
      (Att_qab_q3)
        edge node {} (Dfn_a_q1_q3)
        edge node {} (Dfn_b_q2_q3)
    ;
  \end{tikzpicture}
\end{adjustbox}
```

The bisimulation game of @exm-bisim-sim-game-formulas with attacker formulas.
:::

More generally, the following lemma explains the construction of distinguishing formulas from attacker strategies:

::: {#lem-attacks-imply-formulas}
Let $\rel f$ be a deterministic winning strategy for the attacker on ${\game}_\notionname{B}$ from $[p,q]$.
Construct formulas recursively from game positions, ${φ}_{\rel{f}}(g)$, as follows:

$$
φ_{\rel f}([p,q]) ≔ \begin{cases}
  \hmlneg φ_{\rel f}([q,p])  & \text{if } \rel f([p,q]) = [q,p] \\
  \hmlobs{\alpha} \hmlands \set{ φ_{\rel f}([p',q']) \mid q \step{\alpha} q' } & \text{if } \rel f([p,q]) = (\alpha,p',q)
\end{cases}
$$

Then $φ_{\rel f}([p,q])$ is well-defined and distinguishes $p$ from $q$.
Also, $φ_{\rel f}([p,q]) ∈ \observations{\floor{B}}$.
:::
::: proof
1. The given construction is well-defined as $\rel f$ must induce a well-founded order on game positions in order to be attacker-winning.
2. The distinction can be derived by induction on the construction of $φ_{\rel f}([p,q])$.
   TODO
:::

::: {#lem-formulas-imply-attack}
If $φ ∈ \observations{\floor{B}}$ distinguishes $p$ from $q$, then the attacker wins from $[p,q]$.
:::
::: proof

By induction on the derivation of $φ ∈ \observations{\floor{B}}$ according to the definition from @exm-game-formulas with arbitrary $p$ and $q$.

- Case $φ = \hmlobs{α} \hmland{i}{I} φ_i$.
  As $φ$ distinguishes $p$ from $q$, there must be a $p'$ such that $p \step{α} p'$ and that $\hmland{i}{I} φ_i$ distinguishes $p'$ from every $q' \in \derivatives{q, α}$.
  That is, for each $q' \in \derivatives{q, α}$, at least one $φ_i \in \observations{\floor{B}}$ must be false.
  By induction hypothesis, the attacker thus wins each $[p',q']$.
  As these attacker positions encompass all successors of $(α, p', q)$, the attacker also wins this defender position and can win from $[p,q]$ by moving there with a simulation challenge.
- Case $φ = \hmlneg φ'$.
  As $φ$ distinguishes $p$ from $q$, $φ'$ distinguishes $q$ from $p$.
  By induction hypothesis, the attacker wins $[q, p]$.
  So they can also win $[p, q]$ by performing a swap.\qedhere
:::

{{<noindent>}} @lem-attacks-imply-formulas and @lem-formulas-imply-attack, together with the fact that $\observations{\floor{B}}$ and $\hml$ are equally distincitve (@lem-game-formula-hml), yield:

::: {#thm-game-formulas}
The attacker wins ${\game}_\notionname{B}$ from $[p,q]$ precisely if there is $φ ∈ \hml$ distinguishing $p$ from $q$.
:::

{{<noindent>}} Of course, we already knew this!
@thm-game-formulas is just another way of gluing together the Hennessy–Milner theorem on bisimulation (@thm-hennessy-milner) and the Stirling's bisimulation game characterization (@thm-bisim-game-characterization), modulo the determinacy of games.

## Discussion

Insights:

- Equivalence games (can) correspond to grammars of distinguishing formulas. ... a route to derive equivalence games from modal characterizations! (Prior standard: derive equivalence games from relational characterizations...)
- relational characterizations = defender view; modal characterizations = attacker view.
- HML-theorem a shadow of game determinacy when lifting from games to equivalences
