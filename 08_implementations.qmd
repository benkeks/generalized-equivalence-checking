---
toc-title: "Chapter 8"
---

# Implementations {#sec-implementations}

::: {.content-visible when-format="html"}
{{< include style/macros-html.md >}}
{{< include style/macros.md >}}
:::

All the nice theory of preceding chapters also works *in practice*.
This chapter revisits the core parts of the thesis by discussing how they tie together in a tool implementation.

The tool, {{< equivio >}}, will be presented in @sec-equivio.
We demonstrate its use through the Peterson's mutex example.
@sec-student-implementations shows that the game approach lends itself to many things:
To explain equivalence notions in a computer game, to extend existing tools, and to parallelize equivalence checking through GPUs.
In @sec-implementations-discussion, we compare our implementations to similar tools in the lineage of the “Concurrency Workbench.”

## Prototype: *equiv.io* {#sec-equivio}

The “Linear-time–branching-time spectroscope” on {{<equivio>}} is a small web tool to check equivalence and preorder relations on CCS processes.
@fig-equivio-screenshot shows a screenshot.
In this section, we will discuss its usage (@sec-equivio-usage), apply it to the Peterson example (@sec-equivio-peterson), examine the tool structure (@sec-equivio-structure), and benchmark its backend (@sec-benchmarks).

::: {#fig-equivio-screenshot}

![](img/equivio-peterson.png){.lightbox}

Screenshot of {{< equivio >}}.
:::

### Usage {#sec-equivio-usage}

The standard workflow of {{<equivio>}} is to specify processes in CCS and then compare them with respect to equivalence spectra.
This is mainly achieved by writing text into the source editor on the left. 
The specific order of definitions, queries, and declarations in the source generally makes no difference.

{{< paragraph_heading "Process syntax." >}}
CCS processes are written according to the grammar in @def-ccs, with the concrete syntax for subterms following @tbl-ccs-syntax.

| Construct       | Tool syntax      | $\ccs$                                |
|-----------------|------------------|-----------------------|
| Input prefix    | `a.P`            | $\ccsprefix{\literal a} P$            |
| Output prefix   | `a!P`            | $\ccsprefix{\coaction{\literal a}} P$ |
| Internal action | `tau.P`          | $\ccsprefix{\tau} P$                  |
| Null process    | `0`              | $\ccsnull$                            |
| Recursion       | `P_Name`         | $\literal{P_{Name}}$                  |
| Choice          | `P1 + P2`        | $P_1 \ccschoice P_2$                  |
| Parallel        | `P1 | P2`        | $P_1 \ccspar P_2$                     |
| Restriction     | `P \ {a1, a2}`   | $P \ccsrestrict \set{\literal{a_1}, \literal{a_2}}$ |

: Concrete ASCII syntax for CCS terms {#tbl-ccs-syntax}

\noindent
Literals for actions and process names combine Latin letters, numbers, and underscores in the usual way.

Top-level process definitions are written `X = P`, expressing that $\ccsasg(\literal{X}) \defeq P$ in the semantics (@def-ccs-semantics).
The right-hand pane shows the resulting transition system and output (cf. @fig-equivio-screenshot).

The syntax tree can be clarified by parentheses “`(...)`”.
Otherwise, the parser reads prefix “`a._`” with highest operator precedence, then restriction “`_ \ {_}`”, then choice “`+`” and parallel “`|`” at equal level.
In case of ambiguity, it assumes parenthesization from the right.

{{< paragraph_heading "Equivalence queries." >}}
Queries for the behavioral equivalences between states are formulated in the source editor as well and are started by clicking on the arrows that pop up in the gutter.
Output will appear right below the query in the editor.
The standard queries are:

- `@compare P1, P2` –
  Perform a *spectroscopy* on `P1` and `P2` with respect to the *strong spectrum* using the game of @sec-strong-spectroscopy.
  The output will have four items, relative to the strong spectrum.
  1. The *strongest preorders* to relate `P1` to `P2`;
  2. *Cheapest formulas to distinguish* `P1` from `P2` (and the smallest observation language they are part of);
  3. The list of *finest equivalences* to equate `P1` and `P2`.
  4. A *visualization* of the result on the whole spectrum.
     Moreover, there will be a link to a <https://edotor.net/>-visualization of the game graph used to obtain the result.
  The naming of notions in the output follows @tbl-notion-names.

- `@compareSilent P1, P2` – 
  Perform a *spectroscopy* on `P1` and `P2` with respect to the *weak spectrum*, treating silent steps along the lines of @sec-weak-spectroscopy.
  The output is analogous to `@compare`.
- `@check equivalence-name, P1, P2` –
  Checks for (mutual) preordering between `P1` and `P2` with respect to individual notion `equivalence-name`. 
  The name of the notion to be checked must be one of the ones in @tbl-notion-names.

```{=latex}
% fix to make the table float in spite of Pandoc's hardcoded longtable usage...
\begin{table*}[b!]
\parbox{15cm}{
```

| Strong variant       | Weak variants                      | Stable / stability-respecting variants   |
|:---------------------|:-----------------------------------|:-----------------------------------------|
| `enabledness`          | `weak-enabledness`                   |                                          |
| `trace`                | `weak-trace`                         |                                          |
| `failure`              | `weak-failure`                       | `stable-failure`                         |
| `revivals`             |                                    | `stable-revivals`                          |
| `readiness`            | `weak-readiness`                     | `stable-readiness`                         |
| `failure-trace`        |                                    | `stable-failure-trace`                     |
| `ready-trace`          |                                    | `stable-ready-trace`                       |
| `impossible-future`    | `weak-impossible-future`             | `s-impossible-future`                    |
| `possible-future`      | `weak-possible-future`               |                                          |
| `simulation`           | `weak-simulation`                    | `stable-simulation`                        |
| `ready-simulation`     | `weak-ready-simulation`              | `s-ready-simulation`                       |
| `2-nested-simulation`  | `2-nested-weak-simulation`           |                                          |
| `bisimulation`         | `contrasimulation`<br> `weak-bisimulation`<br> `delay-bisimulation`<br> `eta-bisimulation`<br> `branching-bisimulation` | `stable-bisimulation`<br> `sr-delay-bisimulation`<br> `sr-branching-bisimulation` |

: Names of supported notions in {{<equivio>}}. {#tbl-notion-names .column-body-outset}

``` {=latex}
}
\end{table*}
```

{{< paragraph_heading "Interacting with the output." >}}
Each output item can be clicked.
The transition system view then displays the preorders, equivalences, and distinctions that have been found between states.

States in the transition system may be dragged to change their position.
The layout information is persisted in the source, as described in the next list.

{{< paragraph_heading "Layout and preprocessing." >}}
The source can also contain layout information and prescribe some preprocessing for processes.

- `P(main)` –
  Highlight process `P` in the transition system and prune other sub-processes (unless they are reached from `P`).
  Multiple processes may be declared to be `main`.
- `P(x=100, y=100)` –
  Annotate process `P` to be displayed at certain coordinates.
- `"0"(x=100, y=200)` –
  The annotations may also refer to subprocesses
  The CCS expressions are wrapped in `"..."`.
  They must be verbatim the string representation the tool uses for the normalized process.
- `@preprocessing method1, method2...` –
  Apply preprocessing to the transition system after translation of the CCS term (that is, before presentation and queries happen).
  This will affect the whole transition system, but tries to preserve processes that have been marked as `main`.
  The order of processing steps can make a difference.
  The supported methods are:
  - `weakness_saturated` – Replace the transition relation to with *weak transitions*.
    In effect, there will be a transition whenever the original system allows $\stepweak\stepsoft{\alpha}\stepweak$.
  - `tauloop_compressed_marked` – Collapse states on $\tau$-loops and mark them with a $\delta$.
    (This follows the thought of how to make equivalence queries divergence-respecting from @sec-extending-to-other-eqs.)
  - `bisim_minimized` – Merge states that are strongly bisimilar.
  - `srbb_minimized`  – Merge states that are stability-respecting branching-bisimilar (enforces `tau`-loops precisely on divergent states).
- `@comment "My comment"` –
  Any `@something`-tag without features can serve to add comments in the model.

### Application to Peterson's Mutual Exclusion {#sec-equivio-peterson}

Let us go through the whole process of using the tool once to tackle the example of Peterson's mutual exclusion protocol, which has already been previewed in @exm-peterson-mutex.
Thereby, we settle the question with respect to which equivalences the protocol correctly implements the specification of mutual exclusion.
We follow the presentation of how to model this protocol in CCS from @ails2007reactiveSystems [Chapter 7], with action names chosen to align with @glabbeek2023mutexTimeouts.

We *specify* mutual exclusion as a system `Mx` of two alternating users `A` and `B` entering their critical section `ecA` / `ecB` and leaving `lcA` / `lcB` before the other may enter.
@ails2007reactiveSystems [Equation 7.1] suggest the following specification in CCS:

```ccs
Mx = ecA.lcA.Mx + ecB.lcB.Mx

@snip "----------storage--------"

ReadyAf = readyAf!ReadyAf + setReadyAf.ReadyAf + setReadyAt.ReadyAt
ReadyAt = readyAt!ReadyAt + setReadyAf.ReadyAf + setReadyAt.ReadyAt

ReadyBf = readyBf!ReadyBf + setReadyBf.ReadyBf + setReadyBt.ReadyBt
ReadyBt = readyBt!ReadyBt + setReadyBf.ReadyBf + setReadyBt.ReadyBt

TurnA = turnA!TurnA + setTurnA.TurnA + setTurnB.TurnB
TurnB = turnB!TurnB + setTurnA.TurnA + setTurnB.TurnB

@snip "----------individual processes----------"

A1 = setReadyAt!setTurnB!A2
A2 = readyBf.A3 + turnA.A3
A3 = ecA.lcA.setReadyAf!A1

B1 = setReadyBt!setTurnA!B2
B2 = readyAf.B3 + turnB.B3
B3 = ecB.lcB.setReadyBf!B1

@snip "----------system---------"

Pe = (A1 | B1 | TurnA | ReadyAf | ReadyBf)
    \ {readyAf, readyAt, setReadyAf, setReadyAt, readyBf, readyBt,
       setReadyBf, setReadyBt, turnA, turnB, setTurnA, setTurnB}

@snip "----------preprocessing----------"

Pe(main, x=900, y=340)
Mx(main, x=120, y=220)

@preprocessing srbb_minimized

@snip "----------equivalence-checks----------"

@check weak-trace, Pe, Mx
@check weak-bisimulation, Pe, Mx

@snip "----------spectroscopy queries----------"

@compareSilent Pe, Mx
@compareSilent Mx, Pe

@snip "----alternative spec with internal choice-----"

MxIC(main, x=120, y=0)
MxIC = tau.ecA.lcA.MxIC + tau.ecB.lcB.MxIC
@compareSilent Pe, MxIC

@snip "---------- below here, there's only layout information! ----------"

"(A1 | setTurnA!B2 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1102, y=548)
"(setTurnB!A2 | B1 | TurnA | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=681, y=398)
"(setTurnB!A2 | setTurnA!B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=949, y=636)
"(A1 | B2 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1199, y=767)
"(A1 | B3 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1452, y=961)
"(setTurnB!A2 | B3 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1310, y=1053)
"(A2 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=681, y=802)
"(A3 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=564, y=967)
"(lcA.setReadyAf!A1 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=441, y=1231)
"(lcA.setReadyAf!A1 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=548, y=1297)
"(setTurnB!A2 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=756, y=546)
"(A2 | B3 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1161, y=1116)
"(setTurnB!A2 | lcB.setReadyBf!B1 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1473, y=1257)
"(A1 | lcB.setReadyBf!B1 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1664, y=1102)
"(A2 | lcB.setReadyBf!B1 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1235, y=1348)
"(A2 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=790, y=1112)
"(A2 | B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1067, y=874)
"(setTurnB!A2 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1033, y=427)
"(A2 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=902, y=926)
"(setTurnB!A2 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=910, y=771)
"(A3 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=671, y=1078)
"(A3 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=829, y=1146)
"(lcA.setReadyAf!A1 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=785, y=1350)
"(setReadyAf!A1 | B1 | TurnB | ReadyAt | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=701, y=1061)
"(A1 | B1 | TurnB | ReadyAf | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=806, y=794)
"(setReadyAf!A1 | setTurnA!B2 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=869, y=1064)
"(A1 | setTurnA!B2 | TurnB | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1016, y=535)
"(A1 | B1 | TurnA | ReadyAf | ReadyBf) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=666, y=296)
"(A1 | setReadyBf!B1 | TurnA | ReadyAf | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1542, y=816)
"(setTurnB!A2 | setReadyBf!B1 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1477, y=477)
"(A2 | setReadyBf!B1 | TurnB | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=644, y=761)
"(setReadyAf!A1 | B2 | TurnA | ReadyAt | ReadyBt) \ {readyAf,readyAt,setReadyAf,setReadyAt,readyBf,readyBt,setReadyBf,setReadyBt,turnA,turnB,setTurnA,setTurnB}"(x=1025, y=1064)

"lcA.Mx"(x=181, y=529)
"lcB.Mx"(x=433, y=290)
```

Can one come up with a process where two subprocesses run a protocol such that the overall system is somewhat equivalent to this specification?
@peterson1981mythsMutex proposes a protocol that can be summarized by the following pseudocode:

```ruby
ready = {"A": false, "B": false}
turn  = "A"

def process(ownId, otherId):
  while true:                         # PC = 1
    ready[ownId] = true
    turn = otherId
    
    do # wait...                      # PC = 2
    until (ready[otherId] == false || turn == ownId)
      
    print "enter critical #{ownId}"   # PC = 3
    # critical section goes here.
    print "leave critical #{ownId}"
    ready[ownId] = false

process("A", otherId = "B") || process("B", otherId = "A")
```

The two processes share three variables:
`ready["A"]` expresses whether process `A` is ready to enter its critical section; `ready["B"]` the same for `B`.
In `turn`, *both* processes try to write whose turn it is to enter, `A` or `B`.
Assuming sufficiently consistent memory, the protocol works because each process will only enter the critical section if no other process is waiting or if it has been yielded the turn (by the other process).
The critical scenario of both processes entering *symmetrically* is resolved because the race condition on the `turn`-write will flip a coin in such situations.

To express the shared-memory protocol in the message-passing paradigm of CCS, we must model the storage as processes that run in parallel with the main model.
We do this as @ails2007reactiveSystems:
In the following the process `ReadyAf` corresponds to `ready["A"] = false`, and `ReadyAt` to `ready["A"] = true`.
The current state can be either read (`readyAf` / `readyAt`) or written (`setReadyAf` / `setReadyAt`).

```ccs
@nolink
ReadyAf = readyAf!ReadyAf + setReadyAf.ReadyAf + setReadyAt.ReadyAt
ReadyAt = readyAt!ReadyAt + setReadyAf.ReadyAf + setReadyAt.ReadyAt

ReadyBf = readyBf!ReadyBf + setReadyBf.ReadyBf + setReadyBt.ReadyBt
ReadyBt = readyBt!ReadyBt + setReadyBf.ReadyBf + setReadyBt.ReadyBt

TurnA = turnA!TurnA + setTurnA.TurnA + setTurnB.TurnB
TurnB = turnB!TurnB + setTurnA.TurnA + setTurnB.TurnB
```

Each main process iterates through the phases 1, 2, and 3, corresponding to `PC = 1,2,3` in above pseudocode.
In 1, they set their `ready` and yield the `turn`;
in 2, they wait until they hear that the other's `ready` is false or that it is their `turn`;
in 3, they enter and leave their critical section, unset their `ready`, and return to phase 1.

```ccs
@nolink
A1 = setReadyAt!setTurnB!A2
A2 = readyBf.A3 + turnA.A3
A3 = ecA.lcA.setReadyAf!A1

B1 = setReadyBt!setTurnA!B2
B2 = readyAf.B3 + turnB.B3
B3 = ecB.lcB.setReadyBf!B1
```

Peterson's protocol is the parallel composition of `A1`, `B1` and the storage, restricting communication with the memory:

```ccs
@nolink
Pe = (A1 | B1 | TurnA | ReadyAf | ReadyBf)
    \ {readyAf, readyAt, setReadyAf, setReadyAt, readyBf, readyBt,
       setReadyBf, setReadyBt, turnA, turnB, setTurnA, setTurnB}
```

If you enter above listings, you will notice that the transition system view is cluttered by cycles for the subprocesses.
These can be removed from the system output by declaring `Pe` and `Mx` as the `main` processes:

```ccs
@nolink
Pe(main, x=900, y=340)
Mx(main, x=120, y=220)
```

To further clarify the transition graph, we can minimize it with respect to stability-respecting branching bisimilarity, resulting in the transition system of @fig-peterson-mutex:

```ccs
@nolink
@preprocessing srbb_minimized
```

We can now verify that `Pe` and `Mx` allow for the same weak traces, which, for instance, rules out bugs where both enter, `ecA` and `ecB`, after each other without the other leaving.

```ccs
@nolink
@check weak-trace, Pe, Mx
  > "States are equivalent."
```

But the processes are *not* weakly bisimilar, as tested by:

```ccs
@nolink
@check weak-bisimulation, Pe, Mx
  > "States are not preordered (nor equivalent)"
```

To get the full picture, we run a silent-step spectroscopy:

```ccs
@nolink
@compareSilent Pe, Mx
```

This yields output (also to be seen in @fig-equivio-screenshot):

```markdown
• Preordered by:
    eta-simulation
    stable-simulation
• Left-right-distinguished by:
    ⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecA⟩⊤,¬⟨τ⟩⊤} (stable-failure)
    ⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤} (weak-failure)
• Equated by:
    weak-simulation
```

The maintained notions can also be marked in an overlay on the weak spectrum, as shown in @fig-peterson-spectrum.

The weak failure `⟨ϵ⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤}` can be understood to point out that `Pe` *exceeds* `Mx` in that
it can reach a state without visible activity where `ecB` is impossible.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … thinking about it, this behavior might be okay for a mutual exclusion protocol, might it not?
Why should the outside observer need to be notified about the participating processes making up their minds?
So, maybe, our specification `Mx` is too strict.
Let us try another specification of mutual exclusion where we leave it as an *iterated internal choice* of the system which participant may enter the critical section:

```ccs
@nolink
@comment "Internal-choice mutex"

MxIC(main, x=120, y=0)
MxIC = tau.ecA.lcA.MxIC + tau.ecB.lcB.MxIC

@compareSilent Pe, MxIC
```

`Pe` aligns much better to the `MxIC`-specification!
“`@compareSilent Pe, MxIC`” returns:

```markdown
• Preordered by:
    eta-simulation
    weak-ready-simulation
    s-ready-simulation
• Left-right-distinguished by:
    ⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤,¬⟨τ⟩⊤} (s-impossible-future)
    ⟨ϵ⟩⟨ecB⟩⟨ϵ⟩⟨lcB⟩⋀{¬⟨ϵ⟩⟨ecB⟩⊤} (delay-bisimulation)
    ⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤} (weak-impossible-future)
• Equated by:
    stable-readiness
    eta-simulation
    weak-ready-simulation
```

The output means that implementation `Pe` and internal choice specification `MxIC` cannot be distinguished from each other by a readiness observation (subsuming failures), neither in stable nor weak semantics.
Interestingly, in weak (that is, unstable) semantics the indistinguishability goes even further, up to weak ready simulation.

The tool's visual output of the spectrum for `Pe` vs. `MxIC` (@fig-equivio-screenshot-spectrum) also sports a bigger blue region of equivalence than with the original specification (cf. @fig-peterson-spectrum).

::: {#fig-equivio-screenshot-spectrum fig-pos="t" fig-env="figure*"}

![](img/equivio-spectrum-alt.png){.lightbox}

Spectrum output in {{< equivio >}}.
:::

The main aspect that creates the differences between `Pe` and `MxIC` is that the implementation can decide that `B` will be the next entering the critical section next, even before `A` has left. 
In above output, this is mirrored by the impossible-future formula `⟨ϵ⟩⟨ecA⟩⟨ϵ⟩⋀{¬⟨ϵ⟩⟨lcA⟩⟨ϵ⟩⟨ecA⟩⊤}`.

We can find this scenario already in the pseudo code.
It happens when both processes are in `PC = 2` and `B` has set `turn = A`.
Then, `A` may enter its critical section but has to yield to `B` before it can re-enter.
So, this constitutes a proper difference between Peterson's protocol and a pure iterated internal choice.
But then again, one might say that it is fair of the process going first to leave the next round to the other waiting participant.
In the pure CCS view, however, we cannot adequately treat more general fairness considerations for Peterson's protocol, as @glabbeek2023mutexTimeouts explicates.

This is what the spectroscopy has taught us:
Peterson's mutual exclusion protocol is *more similar* to repeated internal choice (`MxIC`) than to the specification `Mx` from @ails2007reactiveSystems.
However, the two are not bisimilar in any sense, since, in `Pe`, local progress from one iteration may influence the next.

### Program Structure {#sec-equivio-structure}

The core of {{<equivio>}} aligns quite closely to the spectroscopy framework outlined in @fig-strong-spectroscopy-big-picture.
In this subsection, we take a quick look at how implementation and definitions in this thesis correlate.

::: {#fig-equivio-flow fig-pos='t' fig-env="figure*"}
```tikz
%%| image-class: lightbox
\begin{adjustbox}{max width=\linewidth, center}
  \begin{tikzpicture}[auto,node distance=2cm,
    algstep/.style={minimum width=2.5cm, minimum height=1.2cm, draw=gray, fill=white, rectangle,align=center,rounded corners}]
    \node[algstep] (Source) {Source};
    \node[algstep, below of=Source] (Syntax) {CCS system \\ \texttt{ccs.Syntax}};
    \node[algstep, right of=Syntax, node distance=6.1cm] (TS) {Transition system \\ \texttt{WeakTransitionSystem}};
    \node[algstep, below left of=TS, node distance=4.5cm] (SpectroGame) {Game + winning budgets \\ \texttt{StrongSpectroscopyGame}\\ or \texttt{WeakSpectroscopyGame}};
    \node[algstep, right of=TS, node distance=4.5cm, minimum width=3.9cm] (Result) {Result \\ \texttt{SpectroscopyResult}};
    \node[algstep, below of=Result, node distance=1.6cm, minimum width=3.9cm] (Notions) {Finest preorders \\ \texttt{ObservationNotion[]}};
    \node[algstep, below of=Notions, node distance=1.6cm, minimum width=3.9cm] (Formulas) {Distinguishing formulas \\ \texttt{HML.Formula[]}};
    \node[right of=Notions, node distance=6.1cm, align=center] (PriceYesNo) {Price okay? \\ $✔$ / $✗$};
    \node[right of=Formulas, node distance=6.1cm, align=center] (DistinctionYesNo) {Distinguishing? \\ $✔$ / $✗$};
    \node[algstep, above of=Result] (Output) {Visualization};
    \node[above of=SpectroGame, node distance=1.9cm, text=white] (Framework) {\texttt{\textbf{SpectroscopyFramework}}};

    \begin{pgfonlayer}{bg}
      \node[fill=TealBlue!30, rounded corners, densely dotted, thick, inner xsep=.25cm, inner ysep=.34cm, fit=(SpectroGame) (Framework) (PriceYesNo)] {};
      \node[draw=gray, rounded corners, densely dotted, thick, inner xsep=.15cm, inner ysep=.2cm, fit=(Result.center) (Formulas)] {};
    \end{pgfonlayer}

    \draw
      (Source) edge[->, swap] node {\texttt{ccs.Parser}} (Syntax)
      (Syntax) edge[->] node {\texttt{ccs.Interpreter}} (TS)
      ([xshift=-1cm]TS.south) |- ([yshift=.7cm,xshift=-1cm]SpectroGame.north) edge[->] node {\texttt{EnergyGame.populateGame}} ([xshift=-1cm]SpectroGame.north);
    \draw
      ([yshift=.2cm]SpectroGame.east) -| ([xshift=-1.5cm]Notions.west) edge[->, pos=-.1, align=center] node {\texttt{spectrum.}\\\texttt{getStrongest}} (Notions.west);
    \draw
      (SpectroGame.east |- Formulas.west) edge[->, swap] node {\texttt{buildHMLWitness}} (Formulas.west);
    \draw
      (Formulas) edge[->, swap, pos=.6] node {\texttt{hml.Interpreter}} (DistinctionYesNo);
    \draw
      ([yshift=.2cm]Formulas.east) -| ([xshift=.5cm]Formulas.east |- PriceYesNo.west) edge[->, pos=.4, align=center] node {\texttt{spectrum.}\\ \texttt{classifyFormula}} (PriceYesNo);
    \draw[->]
      (Result) -- (Output);

  \end{tikzpicture}
\end{adjustbox}
```

Data transformation flow in equiv.io
:::

@fig-equivio-flow shows core transformations that happen in the process of analyzing the equivalences for a pair of processes:

1. **Parsing.**
    {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" ccs.Parser >}}
    transforms source into an abstract syntax tree object `ccs.Syntax.Definition`, along the lines of @def-ccs with the syntax of @sec-equivio-usage.
2. **Interpretation.**
    {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" ccs.Interpreter >}}
    applies the operational semantics of @def-ccs-semantics^[
      There is a minor semantical difference:
      The {{< equivio >}} interpreter flattens process restriction in recursion.
      This leads to processes like `P = a.P \ {b}` having a finite process graph instead of an infinite one
      [cf. @ails2007reactiveSystems, Exercise 2.9].
    ]
    to construct a {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" ts.WeakTransitionSystem >}}, which supports silent-step transitions of @sec-silent-transitions.
    Also the preprocessing of @sec-equivio-usage is applied, the soundness of which follows @lem-quotienting-spectro-game (and its analogues for the weak spectrum).
3. **Spectroscopy.**
    The trait {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.SpectroscopyFramework >}}
    orchestrates the spectroscopy pipeline.
    Its abstract parts are instantiated by 
    {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.StrongSpectroscopy >}}
    and
    {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.WeakSpectroscopy >}}
    for the respective spectroscopy variants of @sec-strong-spectroscopy and @sec-weak-spectroscopy.
    In particular, they facilitate the following steps in `SpectroscopyFramework.decideAll`:
    1. The spectroscopy defines a *spectroscopy game* (e.g. {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.StrongSpectroscopyGame >}}).
       The game must be a {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" game.EnergyGame >}}, inheriting a decision procedure along the lines of @alg-deciding-energy-games from trait {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" game.GameLazyDecision >}}.
       This computation is invoked together with the game graph construction through `populateGame`.
    2. The spectroscopy provides an {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.Spectrum >}} object which is used to interpret the game result in a hierarchy of {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.ObservationNotion >}}s to pick the strongest preorders to relate compared processes.
        The specifics of @sec-spectrum and @sec-weak-spectrum are implemented by {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.StrongObservationNotion >}} and
        {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.WeakObservationNotion >}}.
    3. The spectroscopy implements a `buildHMLWitness`-method, constructing *strategy formulas* from attacker-won budgets of $\stratstrong$ in @def-strategy-formulas-strong and $\stratweak$ in @def-strategy-formulas-weak.
4. **Validation (optional).**
    If the user demands, the procedure `SpectroscopyFramework.decideAll` continues to construct cheapest distinguishing formulas for the query with `buildHMLWitness`.
    - {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.Interpreter >}} checks that each formula is indeed true for one process and false for the other, applying the semantic HML game of @sec-hml-semantic-game.
      If the formula is not distinguishing, an exception is thrown.
    - `classifyFormula` on the specific `Spectrum` object determines the expressiveness prices of formulas (implemented as in @rem-explicit-expr and @def-weak-spectrum by the `formulaObsNotion` functions in {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.StrongObservationNotion >}} / {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" hml.WeakObservationNotion >}}).
      If the formula price exceeds the budget predicted by the game or is unexpectedly cheap, this constitutes an error.
    
    Error reports would point to incorrectness of the specific spectroscopy, not to user mistakes.
    Thus, the validation does not affect the core decision procedure, but increases confidence that a specific output is sound.

    If no formula construction is requested, the implementation in `SpectroscopyFramework.decideAll` works on *flattened energies* (@def-flattened-energies), generally leading to better performance.
5. **Presentation.**
  `SpectroscopyFramework.decideAll` collects the finest preorders and coarsest distinctions, optionally together with their witness formulas in a `Spectroscopy.Result` object from
  {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.Spectroscopy >}}.
  This object helps front-end layers of the tool interpret the output as spectra, equivalences, and distinguishing formulas.

Another trait {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.EquivalenceChecking >}} follows the second path of @fig-strong-spectroscopy-big-picture to decide individual equivalences.
We will not go into detail here.
The core feature is to derive a reachability game {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" game.MaterializedEnergyGame >}} as in @def-derived-reachability-game.
{{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" game.WinningRegionComputation >}} determines its winner according to @alg-deciding-games.

Besides the core-flow, there are some small additional diagnostic features.
For instance, {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.SpectroscopyFramework >}} can save the spectroscopy game graph and formulas in Graphviz-format using {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" game.GameGraphVisualizer >}}, comparable to @fig-bisim-sim-game-energies.
The output of the same mechanism for {{<code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" spectroscopy.EquivalenceChecking >}} appears, for example, in the derived trace game of @fig-derived-trace-eq-game-true.

:::{#rem-code-size}
#### Line counting

When following the links to source listings above, you might notice that most aspects only take a few hundred lines of code.
Depending on how one counts, a total of 2000–3000 lines fit the two spectroscopies, preorder checking for all the notions, game algorithms, generation and validation of HML formulas, and presentation mechanisms.

As far as code bases go, that size is extremely compact.^[
  For reference, @cs1996ncsuConcurrencyWorkbench report 18,000 LOC for the *NSCU Concurrency Workbench* in Standard&nbsp;ML.
  Performance-centric C++ code bases like mCRL2 [@groote2014mcrl2; @bgklnvww2019mcrl2tacas] are another order of magnitude bigger.
]
In part, this is enabled by Scala's conciseness.
But the heavy lifting in making the implementation so light-weight is achieved by the energy-game abstraction.
:::

:::{#rem-tests}
#### Tests

The codebase of the backend of {{< equivio >}} includes test suites for strong and weak spectroscopy.
These ensure that the algorithms (with and without optimizations) return the expected results for the finitary separating examples of strong and weak spectrum [@glabbeek1990ltbt1; @glabbeek1993ltbt].
This provides some confidence that not too much is going astray on the way between our correctness theorems and optimized implementation.
:::

### Benchmarks {#sec-benchmarks}

Our algorithm and {{< equivio >}} are aimed at small transition systems that “fit onto one screen.”
But still, the backend can analyze the equivalence structure of moderately-sized real-world transition systems.
In this subsection, we examine its performance on the VLTS (“very large transition systems”) benchmark suite @garavel2017vlts and on our recurring Peterson example.

{{< paragraph_heading "Clever strong spectroscopy." >}}
@tbl-strong-spectro-results reports the results of running the backend with the clever strong spectroscopy game $\gamespectroscopyclever$.
This mostly matches the results already reported in @bisping2023equivalenceEnergyGames.^[
  The benchmarking code is contained in the class
  {{< code_link "shared/src/main/scala-2.12/io/equiv/eqfiddle" tool.benchmark.VeryLargeTransitionSystems >}}.
]

```{=latex}
% fix to make the table float in spite of Pandoc's hardcoded longtable usage...
\afterpage{\clearpage
\begin{table*}[b!]
\begin{center}
\parbox{15cm}{
```
```{python}
#| label: tbl-strong-spectro-results
#| tbl-cap: Runtime and results of strong spectroscopy on VLTS examples.
#| tbl-colwidths: [19,10,12,17,12,10,10,13]
#| echo: false


import pandas as pd
import numpy as np
from tabulate import tabulate
import IPython.display as d

# The data is created by repeatedly running the following command
# in the equivalence-fiddle project (and piping its output into a csv file):
#
#     sbt --batch --error "shared/run benchmark --strong-game --reduced-sizes --include-hard --shuffle"

raw = pd.read_csv("data/benchmarking_strong_game.csv", sep=r',', skipinitialspace=True)

examples = pd.DataFrame([
  {"System": "shared/src/test/assets/other/peterson_mutex.csv", "Name": "peterson"},
  {"System": "shared/src/test/assets/vlts/vasy_0_1.csv", "Name": "vasy_0_1"},
  {"System": "shared/src/test/assets/vlts/cwi_1_2.csv", "Name": "cwi_1_2"},
  {"System": "shared/src/test/assets/vlts/vasy_1_4.csv", "Name": "vasy_1_4"},
  {"System": "shared/src/test/assets/vlts/cwi_3_14.csv", "Name": "cwi_3_14"},
  {"System": "shared/src/test/assets/vlts/vasy_5_9.csv", "Name": "vasy_5_9"},
  {"System": "shared/src/test/assets/vlts/vasy_8_24.csv", "Name": "vasy_8_24"},
  {"System": "shared/src/test/assets/vlts/vasy_8_38.csv", "Name": "vasy_8_38"},
  {"System": "shared/src/test/assets/vlts/vasy_10_56.csv", "Name": "vasy_10_56"},
  {"System": "shared/src/test/assets/vlts/vasy_18_73.csv", "Name": "vasy_18_73"},
  {"System": "shared/src/test/assets/vlts/vasy_25_25.csv", "Name": "vasy_25_25"},
])
examples["Name"] = examples["Name"].apply(lambda x: f"`{x}`")

median_times = raw.groupby("System")["Spectroscopy time"].apply(
  lambda x: x.sort_values().iloc[1:-1].mean() / 1000.0 if len(x) > 2 else x.mean() / 1000.0
).reset_index()
examples = examples.merge(median_times, left_on="System", right_on="System", how="left")
columns_to_include = [
  "States", "Transitions", "Bisim pre-minimization time", 
  "Bisim pre-minimized size", "Initial pairs", "Game moves", "enabledness", "trace", "simulation"
]

for column in columns_to_include:
  column_values = raw.groupby("System")[column].first().reset_index()
  examples = examples.merge(column_values, on="System", how="left")

for column in columns_to_include:
  examples[column] = examples[column].apply(lambda x:
    f"{int(x):,}" if (isinstance(x, str) and x.isdigit()) or (isinstance(x, float) and not np.isnan(x))
    else (f"{x:,}" if isinstance(x, int)
    else "-"))

output = examples[["Name", "States", "Bisim pre-minimized size","Game moves", "Spectroscopy time", "enabledness", "trace", "simulation"]]
table = tabulate(
  output.replace(np.nan, None),
  headers=["System", "$\\states$", "$\\quotient{\\states}{\\beq{B}}$", "$\\gamemoveblank_{\\blacktriangle}$", "time&nbsp;(s)", "$\\quotient{\\states}{\\beq{E}}$", "$\\quotient{\\states}{\\beq{T}}$", "$\\quotient{\\states}{\\beq{1S}}$"],
  tablefmt='pipe', 
  showindex=False, 
  numalign="right",
  floatfmt=".2f",
  stralign="right",
  missingval='-'
)

d.Markdown(table)
```

::::{#weak-spectro-results-div}

```{python}
#| label: tbl-weak-spectro-results
#| tbl-cap: Runtime and results of weak spectroscopy on VLTS examples.
#| tbl-colwidths: [19,10,12,17,12,10,10,13]
#| echo: false

import pandas as pd
import numpy as np
from tabulate import tabulate
import IPython.display as d

# The data is created by repeatedly running the following command
# in the equivalence-fiddle project (and piping its output into a csv file):
#
#     sbt --batch --error "shared/run benchmark --reduced-sizes --include-hard --shuffle"

raw = pd.read_csv("data/benchmarking_weak_game.csv", sep=r',', skipinitialspace=True)

examples = pd.DataFrame([
  {"System": "shared/src/test/assets/other/peterson_mutex.csv", "Name": "peterson"},
  {"System": "shared/src/test/assets/vlts/vasy_0_1.csv", "Name": "vasy_0_1"},
  {"System": "shared/src/test/assets/vlts/cwi_1_2.csv", "Name": "cwi_1_2"},
  {"System": "shared/src/test/assets/vlts/vasy_1_4.csv", "Name": "vasy_1_4"},
  {"System": "shared/src/test/assets/vlts/cwi_3_14.csv", "Name": "cwi_3_14"},
  {"System": "shared/src/test/assets/vlts/vasy_5_9.csv", "Name": "vasy_5_9"},
  {"System": "shared/src/test/assets/vlts/vasy_8_24.csv", "Name": "vasy_8_24"},
  {"System": "shared/src/test/assets/vlts/vasy_8_38.csv", "Name": "vasy_8_38"},
  {"System": "shared/src/test/assets/vlts/vasy_10_56.csv", "Name": "vasy_10_56"},
  {"System": "shared/src/test/assets/vlts/vasy_18_73.csv", "Name": "vasy_18_73"},
  {"System": "shared/src/test/assets/vlts/vasy_25_25.csv", "Name": "vasy_25_25"},
])
examples["Name"] = examples["Name"].apply(lambda x: f"`{x}`")

median_times = raw.groupby("System")["Spectroscopy time"].apply(
  lambda x: x.sort_values().iloc[1:-1].mean() / 1000.0 if len(x) > 2 else x.mean() / 1000.0
).reset_index()
examples = examples.merge(median_times, left_on="System", right_on="System", how="left")
columns_to_include = [
  "States", "Transitions", "Bisim pre-minimization time",
  "Bisim pre-minimized size", "Initial pairs", "Game moves", "weak-enabledness", "weak-trace", "weak-simulation"
]

for column in columns_to_include:
  column_values = raw.groupby("System")[column].first().reset_index()
  examples = examples.merge(column_values, on="System", how="left")

for column in columns_to_include:
  examples[column] = examples[column].apply(lambda x:
    f"{int(x):,}" if (isinstance(x, str) and x.isdigit()) or (isinstance(x, float) and not np.isnan(x))
    else (f"{x:,}" if isinstance(x, int)
    else "-"))

output = examples[["Name", "States", "Bisim pre-minimized size", "Game moves", "Spectroscopy time", "weak-enabledness", "weak-trace", "weak-simulation"]]
table = tabulate(
  output.replace(np.nan, None),
  headers=["System", "$\\states$", "$\\quotient{\\states}{\\beq{BB^{sr}}}$", "$\\gamemoveblank_{\\swsimple}$", "time&nbsp;(s)", "$\\quotient{\\states}{\\beq{WE}}$", "$\\quotient{\\states}{\\beq{WT}}$", "$\\quotient{\\states}{\\beq{1WS}}$"],
  tablefmt='pipe', 
  showindex=False, 
  numalign="right",
  floatfmt=".2f",
  stralign="right",
  missingval='-'
)

d.Markdown(table)
```
::::

```{=latex}
}
\end{center}
\end{table*}
}
```

The benchmark uses the VLTS examples of up to 25,000&nbsp;states and the Peterson example.
The table lists the $\states$-sizes of the input transition systems and of their strong bisimilarity quotient system $\quotient{\states}{\beq{B}}$ (@def-quotient-ts).

The test suite constructs the game graph on the quotient system, starting at all positions that compare pairs of enabledness-equivalent states.
The $\gamemoveblank_\blacktriangle$-column reports the size of the discovered game graph in terms of moves.
The **time**-column lists execution times of the spectroscopy procedure in seconds.^[
  Average of mid three runs out of five,
  in the Java Virtual Machine with 8&nbsp;GB heap space, single-threaded on Intel® Core™ Ultra 7 155H.
]

The last three columns list the output sizes of state spaces reduced with respect to enabledness $\notionname{E}$, traces $\notionname{T}$, and simulation $\notionname{1S}$.

From the output, we learn that the VLTS examples, in a way, lack diversity:
Bisimilarity $\notionname{B}$ and trace equivalence $\notionname{T}$ coincide on the systems (third and penultimate column).

Concerning the algorithm itself, the experiments reveal that the computation time grows mostly linearly with the size of the game move graph.
On `vasy_18_73`, the implementation times out after 500 seconds.

Of those terminating, the heavily nondeterministic `cwi_1_2` is the most expensive example.
Almost all of its transitions are labeled by `i`, standing for internal activity $\tau$ in the VLTS suite.
As many coarse notions must record the nondeterministic options, this blow-up is to be expected.
If we compare to the best similarity algorithm by @rt2010efficientSimulation, they report their algorithm SA to tackle `cwi_1_2` single-handedly.
Like our implementation, the prototype of SA of @rt2010efficientSimulation ran out of memory while determining similarity for `vasy_18_73`.
This is in spite of SA theoretically having optimal complexity and similarity being less complex than trace equivalence, which we need to cover (cf. @sec-equivalence-complexities).
The benchmarks in @rt2010efficientSimulation failed at `vasy_10_56`, and `vasy_25_25`, which might be due to 2010's tighter memory requirements (they used 2 GB of RAM) or the degree to which bisimilarity and enabledness in the models is exploited.

{{< paragraph_heading "Simplified weak spectroscopy." >}}
@tbl-weak-spectro-results lists analogous values for the weak spectroscopy game $\gamespectroscopywsimple$, in the simplified variant, but also containing revivals moves of @sec-covering-revivals.

::::{.content-visible when-format="html"}
{{< contents weak-spectro-results-div >}}
::::

The algorithmic setup is slightly changed for the weak setting:
We work with the quotient system of *stability-respecting branching bisimilarity* and start at *weakly* enabledness-equivalent pairs.
The last three columns give the output quotient sizes for weak enabledness $\notionname{WE}$, weak traces $\notionname{WT}$, and weak simulation $\notionname{1WS}$.

The `peterson` example, after minimization, has exactly the 21 states shown in @fig-peterson-mutex.
Its weak similarity quotient is smaller (16 states, cf. last column), which fits our observations that weak similarity equates more in this model than bisimilarity-like notions do.^[
  However, quotient systems need not be minimal for simulation-like and trace-like notions.
  For discussions on weak minimizations of Peterson's mutex, see @bouali1992weakBranchingBisimFCTOOL and @gw1996branchingBisim.
]

In weak semantics, `cwi_1_2` becomes easy, as its internal nondeterminism is directly compressed away by the initial branching-bisimilarity minimization.

Again, we see that branching bisimilarity and weak trace equivalence mostly coincide on the VLTS examples.
Only `vasy_8_24` differs between 170 states in $\quotient{\states}{\beq{BB^{sr}}}$ and 169 in $\quotient{\states}{\beq{WT}}$.

The numbers align with the output of a different implementation in @bn2019coupledsimTacas, which is a good sign for the correctness of both programs.
There, the same samples were analyzed with respect to coupled similarity, a weak notion close to contrasimilarity and weak similarity.
Interestingly, the coupled simulation implementation in @bn2019coupledsimTacas takes minutes for `vasy_25_25`, constructing a game with 126,000 moves.
The trivial game of @tbl-weak-spectro-results suggests that this would not be necessary.

In summary, the equivalences of our spectra mostly coincide on the considered VLTS samples.
This suggests that the examples are based around models that avoid the expressive power of finer branching-time notions.

## Student Implementations {#sec-student-implementations}

There exist three other implementations of the equivalence spectroscopy algorithm by students of mine.
Each covers a different direction:
In @sec-spectro-invaders, we discuss *The Spectroscopy Invaders*, a computer-game version, which has an educational purpose.
@sec-spectroscopy-caal presents an extension to an existing educational tool, the Concurrency Workbench Aalborg Edition.
@sec-gpu-equiv closes by reporting on *gpuequiv*, a performance-centric shader-based implementation using the modern WebGPU standard.

### Computer Game: *The Spectroscopy Invaders* {#sec-spectro-invaders}

Would it not be nice if one could *play* the spectroscopy game *as a game*?

@trzeciakiewicz2021ltbtBrowserGame develops the computer game “The Spectroscopy Invaders” where one plays the attacker in the spectroscopy game.
You can enjoy the game in the browser at <https://concurrency-theory.org/ltbt-game/>.

A play of the game corresponds to naming a universal attack strategy in the strong spectroscopy game of @def-strong-spectroscopy-game, or, equivalently, to constructing a distinguishing formula.
To reach maximal level scores, one has to play out a minimal formula in the sense of our pricing.
Under the hood, the TypeScript implementation uses Bisping et al.'s [-@bjn2022decidingAllBehavioralEqs] algorithm to compute the minimal budgets.
The game does not present the costs of moves to the player,
but they matter for the scores received at the end of a level.

:::{#fig-spectro-invaders-screenshot-simple fig-pos="t!"}

:::: {.content-visible when-format="html"}
{{< video https://github.com/Marii19/the-spectroscopy-invaders/raw/refs/heads/main/public/assets/videos/negation_move.mp4 >}}
::::
:::: {.content-visible unless-format="html"}
![](img/spectro-invaders-2.png){.lightbox}
::::

Screenshot of browser game “The Spectroscopy Invaders.”
:::

@fig-spectro-invaders-screenshot-simple gives a screenshot of the first level of the “Failure” world.^[
  In the online version of this thesis, it is actually a screen capture by Trzeciakiewicz, illustrating negation moves in the game tutorial.
]
This level corresponds to the classic @exm-ts of $\literal{P}$ and $\literal{Q}$ if we match the orange transitions to $\tau$-steps, blue to $\literal{a}$, and yellow to $\literal{b}$.
The metaphor on top of the game mechanics is that the human-controlled hero (left) has to outmaneuver a group of elves (right) that might split up on nondeterministic transitions.

From @exm-spectroscopy-classic-ts, we know that the failure $\hmlobs{\tau}\hmlneg\hmlobs{\literal{a}}$ is a cheapest distinction of the left state from the right in this system,
translated as $\hmlobs{\literal{orange}}\hmlneg\hmlobs{\literal{blue}}$.
In the computer game, we would use this distinction as follows:
First click on the state behind the middle orange transition to *observe* it.
Then, click on the “negation” button ![](img/spectro-invaders-swap.png){width=1em} to swap sides of hero and elve.
Defeat them by moving along the right blue edge.

The handling of conjunctions is a little more involved.

:::{#fig-spectro-invaders-screenshot fig-pos="t"}

![](img/spectro-invaders-1.png){.lightbox}

Second level of *Simulation* world.
:::

\noindent
@fig-spectro-invaders-screenshot shows the second level of the “Simulation” world.
In the level, the player's task is to distinguish
$\ccsprefix{\literal{white}}(\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange})$ (left) from
$\ccsprefix{\literal{white}}(\literal{red}\ccschoice\literal{orange}) \ccschoice \ccsprefix{\literal{white}}\ccsprefix{\literal{orange}}\literal{orange}$ (right).
The current game position occurs after the first white observation and corresponds to $\attackerpos{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \set{\literal{red}\ccschoice\literal{orange}, \ccsprefix{\literal{orange}}\literal{orange}}}$ in the strong spectroscopy game $\gamespectroscopy$,
as indicated by the hero figure on the left and the two elves on the right.

The player can click the “conjunct” button ![](img/spectro-invaders-conjunction.png){width=1em},
after which they have to explain how to win $\attackerpos[\land]{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \literal{red}\ccschoice\literal{orange}}$
and then $\attackerpos[\land]{\literal{red} \ccschoice \ccsprefix{\literal{orange}}\literal{orange}, \ccsprefix{\literal{orange}}\literal{orange}}$.
In the split state, the player can first click through the yellow-arrow successor states on the left to point out that the left elve cannot observe two yellow steps.
Then, they also have to name how to defeat the right elve, by taking the red transition.
Together, this strategy corresponds to the simulation formula $\hmlands\set{\hmlobs{\literal{yellow}}\hmlobs{\literal{yellow}}, \hmlobs{\literal{red}}}$.

The game is single-player, also in a theoretical sense:
There is no picking of conjunction answers by the defender.
Instead, the attacker has to name attacks for every right-hand state.
Due to nested conjunctions, the game positions thus actually are sets of $\attackerpos{p, Q}$ tuples.

@trzeciakiewicz2021ltbtBrowserGame limits the scope to (strong) trace, failure, possible-future, simulation, and bisimulation equivalences,
excluding notions like readiness, ready traces, and failure traces.
The selection permits slightly simpler game rules---in particular, without revival moves.
This allows to nicely showcase the core mechanics of @sec-strong-spectroscopy with a stricter correspondence to productions in the original HML of @def-hml.

### CAAL Extension {#sec-spectroscopy-caal}

Would it not be nice if one could use the equivalence spectroscopy in *existing tools*?

@ozegowski2023eqCAAL integrates the spectroscopy algorithm into *CAAL*, the “Concurrency Workbench Aalborg Edition” by Andersen et al. -@aaehlow2015caal.
@strassnickOzegowski2024weakCAAL also add the weak spectroscopy game and possibilities to play the spectroscopy game in the tool.
Their extended version of CAAL is live on <https://equivio.github.io/CAAL/>.

The original CAAL (on <https://caal.cs.aau.dk/>) covers the curriculum of *Reactive systems* [@ails2007reactiveSystems], including CCS processes, HML formulas and equivalence games.

Originally, CAAL only supports preorder/equivalence checking for six standard notions, namely for simulation, bisimulation, and traces, in their standard strong and weak variants.
Only simulation and bisimulation can be examined as games.

Straßnick and Ozegowski's extended CAAL version supports 13 strong and 21 weak notions.
Each of the notions can be decided individually, or in the context of a spectroscopy.
For the strong notions, the game graph can be explored interactively.
@fig-caal-screenshot shows the output of strong and weak spectroscopy on the classic @exm-ts, together with a generated distinguishing failure formula in the HML dialect of CAAL.

:::{#fig-caal-screenshot fig-pos="t!"}

![](img/caal-extension.png){.lightbox}

Extended version of CAAL, performing a spectroscopy.
:::

For a usage guide, we refer to @strassnickOzegowski2024weakCAAL.

At some points, Straßnick and Ozegowski's fork unfortunately has to remain partial with respect to features.
For instance, the extension does not support distinguishing formulas for the weak spectroscopy because CAAL's HML dialect cannot easily be molded to support $\hmlsrbb$.

Still, the project shows that the spectroscopy approach is sufficiently simple and versatile to allow dozens of equivalence checkers to be integrated into existing tools within the limited scope of a student project.

### GPU Implementation: *gpuequiv* {#sec-gpu-equiv}

Would it not be nice if one could use modern hardware to perform spectroscopies as fast as possible?

@vogel2024energyGamesWebGPU implements the strong equivalence spectroscopy in *gpuequiv* using shaders in the WebGPU Shading Language [@w3c2025wgsl].

Technically, this is superior to the other three implementations of this chapter, which can only exploit the single-threaded CPU model of JavaScript when running in the browser.

Historically, the WebGL standard for browser graphics processing has lacked compute shaders.
This has made it difficult to access the computational power of graphics processing units from within web applications.
Times are changing with WebGPU/WGSL [@w3c2025wgsl].
@vogel2024energyGamesWebGPU makes this technological progress available to the spectroscopy approach.

Big parts of the game graph construction and the game solving are quite parallelizable.
gpuequiv parallelizes the budget computation of @alg-deciding-energy-games.
For instance, a whole batch of game positions on a `todo`-list can be processed simultaneously.
The details are explained by @vogel2024energyGamesWebGPU.

gpuequiv's control code surrounding the shader invocations is written in Rust that can be compiled to native code and to WebAssembly.
Therefore, gpuequiv can be compiled for both kinds of targets:
Quick equivalence checking in the browser, and even quicker checking in a native application.
@vogel2024energyGamesWebGPU reports 10⨯ speed-ups compared to @bisping2023equivalenceEnergyGames.
However, the fast growth of game graphs remains a limiting factor as larger examples run into the size boundary of buffers to upload game moves.
For `vasy_18_73`, @vogel2024energyGamesWebGPU also fails to complete the spectroscopy (like our experience in @sec-benchmarks):
It constructs a game graph of 623,482,227 moves, but only 536,870,911 moves fit into the buffer with the employed data packing.

At the time of writing, another Bachelor project is underway to add a frontend and support for the *weak* spectroscopy game to gpuequiv.

## Discussion {#sec-implementations-discussion}

In this chapter, we have surveyed the four existing implementations of the spectroscopy algorithm.

We focused on {{< equivio >}}, which closely aligns with this thesis.
We have seen how the tool easily answers questions such as “How equivalent is Peterson's algorithm to the specification of mutual exclusion.”
{{< equivio >}} can check behavioral preorders and equivalences for more than 38 notions of strong and weak spectrum.
Due to the possibility to mark divergences, even more notions are available.

{{< paragraph_heading "Other tools." >}}
A recent survey by @gl2022eqChecking lists hundreds of tools to check bisimilarity and related equivalences and preorders.
Some of them can justify their output with distinguishing formulas (or traces), similar to our approach.
Many specific tools address special equivalences, for instance for open, timed, or probabilistic systems, which we do not support.
On the other hand, {{<equivio>}} might be the first tool to cover some of the more arcane notions of the weak spectrum [@glabbeek1993ltbt], such as $\eta$-similarity and stable bisimilarity.

In @tbl-tool-comparison, we compare the supported notions of {{<equivio>}} to four current state-of-the-art tools.
A tick ✔ stands for direct support, (✔) for support via preprocessing.

```{=latex}
\afterpage{\clearpage
% fix to make the table float in spite of Pandoc's hardcoded longtable usage...
% push to next page to fix the problem of longtable breaking pages with other floats -_-
\begin{table}[b!]
```
::: {#tbl-tool-comparison}

| Equivalence / preorder                  | equiv.io | CAAL  | mCRL2 | CADP | FDR4 |
|:-----------------------------------|:-----:|:-----:|:-----:|:-----:|:-----:|
| Strong / weak enabledness               | ✔       |       |       |      |      |
| Strong trace                            | ✔       | ✔     | ✔     |  ✔   |      |
| Weak trace                              | ✔       | ✔     | ✔     |  ✔   |  ✔   |
| Strong failure                          | ✔       |       | ✔     |      |      |
| Weak failure                            | ✔       |       |       |      |      |
| Stable failure                          | ✔       |      | ✔     |      |  ✔   |
| Failure-divergence                      | (✔)     |      | ✔     |      |  ✔   |
| Strong / stable revivals                | ✔       |       |       |      |      |
| Strong / weak / stable readiness        | ✔       |       |       |      |      |
| Strong / stable failure-trace           | ✔       |       |       |      |      |
| Strong / stable ready-trace             | ✔       |       |       |      |      |
| Strong / stable impossible fut.         | ✔       |       |       |      |      |
| Weak impossible future                  | ✔       |       | ✔     |      |      |
| Strong / weak possible future           | ✔       |       |       |      |      |
| Strong simulation                       | ✔       | ✔     | ✔     |      |      |
| Weak simulation                         | ✔       | ✔     |       |      |      |
| Stable simulation                       | ✔       |       |       |      |      |
| $\eta$-simulation                       | ✔       |       |       |      |      |
| Safety / $\tau^*.a$                     |         |       |       |  ✔   |      |
| Strong ready-simulation                 | ✔       |       | ✔     |      |      |
| Weak / stable ready-simulation          | ✔       |       |       |      |      |
| 2-nested strong / weak sim.             | ✔       |       |       |      |      |
| Strong bisimulation                     | ✔       | ✔     | ✔    |  ✔   | (✔)  |
| Contrasim. / stable bisim.              | ✔       |       |       |      |      |
| Coupled simulation                      |         |       | ✔     |      |      |
| Weak bisimulation                       | ✔       | ✔     | ✔     |  ✔   | (✔)  |
| Div.-pr. weak bisim.                    | (✔)     |       | ✔     |      | (✔)  |
| Delay bisimulation                      | ✔       |       |       |      | (✔)  |
| Stability-resp. delay bisim.            | ✔       |       |       |      |      |
| $\eta$-bisimulation                     | ✔       |       |       |      |      |
| Branching bisimulation                  | ✔       |       | ✔     |  ✔   |      |
| Stability-resp. branch. bisim.          | ✔       |       |       |      |      |
| Div.-pr. branching bisim.               | (✔)     |       | ✔     |      | (✔)   |

Comparison of supported notions.
:::

``` {=latex}
\end{table}
}
```

- **CAAL** [@aaehlow2015caal], or the “Concurrency Workbench Aalborg Edition,” also works with CCS and has already been discussed in @sec-spectroscopy-caal.^[
    @aha2015caal2games [§ 3.3] also mention how to use their game backend to handle 2-nested simulation and ready-traces.
    But this is neither elaborated upon nor supported in the frontend.
  ]
- **mCRL2** [@groote2014mcrl2], built around an ACP/CCS-like modelling language of the same name, supports a wide-range of notions with highly efficient implementations and a strong focus on branching bisimilarity.
  On the notions it supports, it will generally be much faster than the spectroscopy game algorithm.
  The only notion that is exclusively supported by mCRL2 is coupled similarity, implemented by @le2020coupledSimMcrl2.
- **CADP** [@garavel2013cadp] can check several notions on-the-fly, also in a highly optimized fashion.
  Its models are usually expressed in LOTOS or LNT, deriving from CSP.
  It includes the special notions of safety- and $\tau^*\!.a$-equivalence, not present in van Glabbeek's spectrum [-@glabbeek1993ltbt].
- **FDR4** [@grabr2014fdr] has “Failures Divergences Refinement” in its name, but also supports different linear-time refinement models for CSP.
  Branching-time notions are partially supported as minimizers.

Like the listed tools, {{<equivio>}} can be seen as following the tradition of the discontinued “Concurrency Workbench[es]” [@cps1990concurrencyWorkbench; @cs1996ncsuConcurrencyWorkbench].

{{< paragraph_heading "Other avenues for implementation." >}}
The implementations of this chapter realize @alg-deciding-energy-games quite directly to decide energy games.
Among them, the shader version of @sec-gpu-equiv adds the highest level of implementation cleverness with respect to packing of data and parallelization of computation.
But so far, we are not using the full toolbox of the computer-aided-verification community.

For instance, the upward-closed sets of winning budgets could be handled more symbolically with the representation of @dr2000symbolicUpwardClosedSets.
This might slightly increase how many Pareto fronts can be kept in memory.
But one can expect that its payoff would be meager, especially on the small $\set{0,1,\infty}^d$-lattices.
Experiments by @vogel2024energyGamesWebGPU suggest that the Pareto fronts usually stay sufficiently small that adding the implementation complexity of @dr2000symbolicUpwardClosedSets seems uncalled for.

A big limiting factor of our implementations is the storage of the game graph.
To some extent, this can be battled by more symbolic representations as *binary-decision-diagrams*.
@bulychev2011gameSimulation and @wimmer2011dissertation follow this route in quite versatile checkers.

A more general solution for the memory limitations would be to forget parts that have been visited, and recompute them *by-need*.
There are easy ways to profit from the community's advances in handling big spaces of possibilities.
The most prominent would be to instantiate the game rules for a transition system, and feed them into an SMT solver.
Already @shr1995hornsatGames suggest a comparable approach, viewing games as SAT problems.
The energy aspect should be perfectly expressible for SMT/SAT solvers in linear integer arithmetic [cf. @chistikov2024linearIntegerArithmetic].

{{< paragraph_heading "Alternative paths to generalized checkers." >}}
In @sec-preliminaries-discussion, we have already discussed the alternative paradigms of equivalence checking.
The *equivalences-as-game-instances* approach seems to be the most fruitful when one wants to easily support a wide range of preorders and equivalences in a tool.
By “easy,” we mean: without the need to implement individual algorithms for each of the notions.
@tan2002abstractEquivalenceGames takes a similar game approach for the Concurrency Workbench, as do @aha2015caal2games for CAAL.

Another route to this goal of genericity might be the *equivalences-as-formulas* approach from @lange2014modelCheckingProcEqs.
The idea there is to use a *diadic higher-order $\mu$-calculus* where one can talk about relations between states.
Thereby, the rules of how to preorder states can be expressed as formulas.
One only needs to implement the model-checking for formulas once, and new notions could be added by only adding new formulas.
@stoecker2024HOcalculiEqs implements this idea successfully.
But the data suggests that 20 states already demand several seconds in this approach for some equivalences.

The third path to genericity is through *equivalences-as-functors*, to enable *coalgebraic partition-refinement algorithms* from category theory.
We already hinted to this in @sec-preliminaries-discussion.
@dmsw2019genericPartitionRefinement follow this route in their tool *CoPaR* (short for “Coalgebraic Partition Refiner”).
This way, the support of new equivalences boils down to a few lines of defining new functors.
The big advantage is that extensions---for instance, to quantitative behavioral distances---can also be achieved this way.
The coalgebraic approach is related to the game approach and, too, can derive distinguishing formulas, as seen for instance in the tool T-BEG [@km2020nonBisimCoalgebraic].
However, encoding simulation-like preorders in category theory seems to be non-trivial if one compares the machinery of @rt2010efficientSimulation to the ease of just leaving out swap-moves in the bisimulation game.
It is difficult to say whether it is conceptional boundaries or the coating in category-theory parlance that has hindered a wider adoption in tools.

A light-weight variant of the functor-approach is offered by *equivalences-as-signatures*.
Tools like *Sigref* [@whhsb2006sigref] support a broad range of bisimulation-like equivalences.
The specifics of individual equivalences are expressed as *signatures* that prescribe how to refine equivalence classes in an iterative partition-refinement.
Signature Refinement can easily be boosted by parallelization or symbolic BDD-encodings.

Of course, all these theoretical approaches are linked on some basic level, namely through the Hennessy–Milner theorem (@thm-hennessy-milner).
We elaborate on this in the conclusion.