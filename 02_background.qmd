---
title: "Preliminaries: Communicating Systems and Games"
filters:
- teximg
---

{{< include style/macros.md >}}

TODO: Preliminaries....

## Behavior of Programs

### Labeled Transition Systems

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.
:::

{{<noindent>}} There is a canonical example used to discuss equivalences within transition systems.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#exm-ts}
#### A Classic Example

  Consider the LTS given by the following graph:
  
  ```{mermaid}
  flowchart TD
    p0(P) -- τ --> pAB(pAB)
    pAB -- a --> pA( )
    pAB -- b --> pB( )

    q0(Q) -- τ --> qA(qA)
    q0 -- τ --> qB(qB)
    qA -- a --> qA0( )
    qB -- b --> qB0( )
  ```

  {{<noindent>}}
  The program described by the transitions from $\literal{P}$ performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$.
  The program $\literal{Q}$ on the other hand first decides non-deterministically during a $\tau$-step between two options and then offers only either $\literal a$ *or* $\literal b$.

:::

::: {#fig-henzinger}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.

:::

{{<noindent>}}
There are two things one might wonder about @exm-ts:

1. What leads to non-determinism in concurrent programs?
2. Should one consider $\literal P$ and $\literal Q$ equivalent?

### Calculus of Communicating Systems

To talk about programs in this thesis, we will use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS).

::: {#def-ccs}
#### Calculus of Communicating Systems

Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions := \ccschannels \cup \set{ \coaction{\alpha} \mid \alpha \in \ccschannels } \cup \set{τ}$, are given by the following grammar:

$$
\begin{array}{cllr}
  P \grammardef
  & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
      \text{“input action prefix”} \\
  & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
      \text{“output action prefix”} \\
  & \ccsprefix{τ} P & &
      \text{“internal action”} \\
  & P \ccschoice P & &
      \text{“choice”} \\
  & P \, \ccspar \, P & &
      \text{“parallel composition”} \\
  & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
      \text{“restriction”}
\end{array}
$$
We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.

Given an assignment of names to processes, $\ccsasg \colon \ccsnames \to \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{a}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$
$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$
$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$
$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
:::
{{< noindent >}}A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.


::: {#exm-ccs}
#### CCS Hello world

Consider the simple process
It...

See @fig-hello-world for the semantics.

::: {#fig-hello-world}

  Process of example @exm-ccs.

:::

:::

## Behavioral Equivalences

### Trace Equivalence

::: {#def-traces}
#### Traces

The set of traces of a process $\traces{p}$ is recursively defined as

- $() ∈ \traces{p}$,
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.

:::

::: {#def-trace-eq}
#### Trace Equivalence

Two processes $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.

Processes are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.
:::

### Simulation and Bisimulation

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.

:::


::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation-preorder, similarity and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.
:::


## Observations as Modal Logic

::: {#def-observations}
#### Hennessy–Milner Logic

For a set of actions $\actions$, the *observations* (expressed as Hennessy–Milner logic $\hml$) follow the grammar:

$$
\begin{array}{cllr}
  \varphi \grammardef &
    \hmlobserve{α}\varphi & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    {}\grammaror \quad & \hmland{i}{I}\varphi_i & \quad\text{with index set } I & \text{“conjunction”} \\
    {}\grammaror \quad & \hmlneg \varphi & & \text{“negation”} \\
\end{array}
$$
Its semantics $\semantics{\cdot} \colon \hml \to \powerset{\states}$ is defined by:

```{=latex}
\begin{mathpar}
\inferrule*{
  p \step{a} p' \\ p' ∈ \semantics{\varphi}
}{
  p ∈ \semantics{\hmlobserve{a}\varphi}
}\and
\inferrule*{
  \forall i ∈ I \ldotp p ∈ \semantics{\varphi_i}
}{
  p ∈ \semantics{\hmland{i}{I}\varphi_i}
}\and
\inferrule*{
  p \notin \semantics{\varphi}
}{
  p ∈ \semantics{\hmlneg\varphi}
}

\end{mathpar}
```
:::

::: {#lem-hennessy-milner}

#### Hennessy–Milner Theorem

:::

<!-- We now use observations to give a denotational semantics for our $\ccs$ processes (overloading $\semantics{\cdot}$):

::: {#def-denotational}
#### Denotations

The denotational semantics of processes, $\semantics{\cdot} \colon \states \to \powerset{\hml}$, is defined:
$$\semantics{P} := \{ \varphi ∈ \hml \mid P ∈ \semantics{\varphi} \}.$$
::: -->



## Reachability Games

Definition Game

Small example game

Semantics as Game

