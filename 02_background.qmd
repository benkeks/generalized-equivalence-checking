---
title: "Preliminaries: Communicating Systems and Games"
---

{{< include style/macros.md >}}

TODO: Preliminaries....

## Behavior of Programs

### Labeled Transition Systems

::: {#def-ts}
#### Transition Systems

A *labeled transition system* (LTS) $\system=(\states,\actions,\step{})$ consists of

- $\states$, a set of *states,*
- $\actions$, a set of *actions,* and
- ${\step{}} ⊆ \states × \actions × \states$, a *transition relation*.
:::

{{<noindent>}} There is a canonical example used to discuss equivalences within transition systems.
We will take the formulation that Henzinger used at CAV'23 as seen in @fig-henzinger.

::: {#fig-henzinger .column-margin}

  ![](img/henzinger.jpg){.lightbox}

  Tom Henzinger employing @exm-ts during CAV'23.
:::

::: {#exm-ts}
#### A Classic Example

  Consider the transition system $\system_\literal{PQ} = (\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}, \set{\literal a, \literal b, τ}, \step{\cdot}_\literal{PQ})$ given by the following graph:

::::{#fig-ts-determinism fig-pos=H}
  ```{mermaid}
  flowchart TD
    p0([P]) -- τ --> pA([p<sub>a</sub>])
    p0 -- τ --> pB([p<sub>b</sub>])
    pA -- a --> pA0([p<sub>1</sub>])
    pB -- b --> pB0([p<sub>2</sub>])

    q0([Q]) -- τ --> qAB([q<sub>ab</sub>])
    qAB -- a --> qA([q<sub>1</sub>])
    qAB -- b --> qB([q<sub>2</sub>])
  ```

  Example system $\system_\literal{PQ}$.
::::

  {{<noindent>}}
  The program described by the transitions from $\literal{P}$ choses non-deterministically during a $τ$-step between two options and then offers only either $\literal a$ *or* $\literal b$.
  The program $\literal{Q}$ on the other hand performs a $τ$-step and then offers the choice between options $\literal a$ and $\literal b$ to the environment.
:::


{{<noindent>}}
There are two things one might wonder about @exm-ts:

1. Should one care about non-determinism in programs? Subsection [-@sec-ccs] shows how non-determinism arises naturally in concurrent programs.
2. Should one consider $\literal P$ and $\literal Q$ equivalent? This heavily depends. Section [-@sec-behavioral-eq] will introduce a notion of equivalence under which the two are equivalent and one under which they differ.

### Calculus of Communicating Systems {#sec-ccs}

To talk about programs in this thesis, we will use Milner's [-@milner1989comcon] *Calculus of Communicating Systems* (CCS).

::: {#def-ccs}
#### Calculus of Communicating Systems

  Let $\ccschannels$ be a set of channel names, and $\ccsnames$ a set of process names. Then, $\ccs$ processes, communicating via actions $\ccsactions ≔ \ccschannels \cup \set{ \coaction{α} \mid α ∈ \ccschannels } \cup \set{τ}$, are given by the following grammar:

  $$
  \begin{array}{cllr}
    P \grammardef
    & \ccsprefix{α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“input action prefix”} \\
    & \ccsprefix{\coaction α} P & \quad\text{with } α ∈ \ccschannels &
        \text{“output action prefix”} \\
    & \ccsprefix{τ} P & &
        \text{“internal action”} \\
    & \ccsnull & &
        \text{“null process”} \\
    & X & \quad\text{with } X ∈ \ccsnames &
        \text{“recursion”} \\
    & P \ccschoice P & &
        \text{“choice”} \\
    & P \, \ccspar \, P & &
        \text{“parallel composition”} \\
    & P \, \ccsrestrict A & \quad\text{with } A ⊆ \ccschannels &
        \text{“restriction”}
  \end{array}
  $$
  We call pairs of actions $α$ and $\coaction α$ *coactions*, and work with the aliasing $\coaction{\coaction{α}} = α$.
  The intuition is that an action $α$ represents receiving and $\coaction α$ expresses sending in communication.
  A pair of action and coaction can “react” in a communication situation and only become internal activity $τ$ in the view of the environment.

  Each sub-process tree must end in a $\ccsnull$-process or recursion.
  For brevity, we usually drop a final $\ccsnull$ when writing terms, e.g., just writing $\literal{ac}$ for $\ccsprefix{\literal{ac}} \ccsnull$.

  We place parenthesis, $(…)$, in terms where the syntax trees are otherwise ambiguous, but understand the choice operator $\ccschoice$ and the parallel operator $\ccspar$ to be associative.
:::

::: {#exm-ccs}
#### Concurrent Philosophers

  Following tradition, we will express our examples in terms of philosophers who need forks to eat spaghetti.^[
    Of course, you can just as well read the examples to be about computer programs that race for resources.]
  So, consider two philosophers $\literal{P_A}$ and $\literal{P_B}$ who want to grab a resource $\literal{fork}$ modeled as an action in order to eat where we express $\literal{P_A}$ eating with action $\literal{a}$ and $\literal{P_B}$ eating with $\literal{b}$.
  The philosopher processes read:

:::::: {.column-margin}
  ```{mermaid}
  flowchart TD
    p0([P<sub>A</sub>]) -- fork --> pA([a.0])
    pA -- a --> 0([<strong>0</strong>])
  ```
::::::

  $$
  \begin{gathered}
    \literal{P_A} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal a} \ccsnull \\
    \literal{P_B} ≔ \ccsprefix{\literal{fork}} \ccsprefix{\literal b} \ccsnull
  \end{gathered}
  $$
  An LTS representation of $\literal{P_A}$'s behavior can be seen in the margin.
  Process $\literal P$ captures the whole scenario where the two philosophers compete for the fork using communication:
  $$
    \literal P ≔ ( \ccsprefix{\coaction{\literal{fork}}} \ccsnull \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  $$
  The restriction $… \ccsrestrict \set{\literal{fork}}$ expresses that the $\literal{fork}$-channel can only be used for communication within the system.

  As the $\coaction{\literal{fork}}$-action can be consumed by just one of the two philosophers, process $\literal P$ expresses exactly the program behavior seen in state $\literal P$ of @exm-ts.
:::

{{<noindent>}} The formal relationship between process terms and their LTS semantics is given by the following definition.

::: {#def-ccs-semantics}
#### CCS Semantics

Given an assignment of names to processes, $\ccsasg \colon \ccsnames → \ccs$, the operational semantics ${\step{\cdot}_\ccs} ⊆ \ccs × \ccsactions × \ccs$ is defined inductively by the rules:

$$
\dfrac{
}{
  \ccsprefix{α} P \step{α}_\ccs P
}
\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad \ccsasg(X) = P
}{
  X \step{α}_\ccs P'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_1'
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccschoice P_2 \step{α}_\ccs P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1' \ccspar P_2
}\qquad
\dfrac{
  P_2 \step{α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{α}_\ccs P_1 \ccspar P_2'
}
$$

$$
\dfrac{
  P_1 \step{α}_\ccs P_1' \qquad
  P_2 \step{\coaction α}_\ccs P_2'
}{
  P_1 \ccspar P_2 \step{τ}_\ccs P_1' \ccspar P_2'
}\qquad
\dfrac{
  P \step{α}_\ccs P' \qquad
  α, \coaction α \notin A
}{
  P \ccsrestrict A \step{α}_\ccs P' \ccsrestrict A
}
$$
A process $P ∈ \ccs$ now denotes a position in the transition system $(\ccs, \ccsactions, \step{}_\ccs)$ defined through @def-ccs.
:::

{{< noindent >}} Feel free to go ahead an check that the transitions of @exm-ts indeed match those that @def-ccs-semantics prescribes for $\literal{P}$ of @exm-ccs!
(For readability, @exm-ts, has shorter state names, however.)
For instance, the transition $\literal P \step{τ} \literal{p_a}$ of @exm-ts would be justified as follows:

::: {.column-body-outset}
$$
\dfrac{
  \dfrac{
    \dfrac{
      \dfrac{
        \vphantom{\step{\coaction{\literal{fork}}}_\ccs}
      }{
        \coaction{\literal{fork}} \step{\coaction{\literal{fork}}}_\ccs \ccsnull
      }
      \quad
      \dfrac{
        \dfrac{
          \overline{
            \ccsprefix{\literal{fork}} \literal a
            \step{\literal{fork}}_\ccs
            \literal a
          }
          \qquad
          \ccsasg(\literal{P_A}) = \ccsprefix{\literal{fork}} \literal a
        }{
          \literal{P_A} \step{\literal{fork}}_\ccs \literal a
        }
      }{
        \literal{P_A} \ccspar \literal{P_B} \step{\literal{fork}}_\ccs \literal a \ccspar \literal{P_B}
      }
    }{
      \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B}
      \step{τ}_\ccs
      \ccsnull \ccspar \literal a \ccspar \literal{P_B}
    }
    \quad
    \begin{matrix}
      \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
      τ \notin A
    \end{matrix}
  }{
    ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
    \step{τ}_\ccs
    ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  }
  \quad
  \begin{matrix}
    \vphantom{\step{\coaction{\literal{fork}}}_\ccs}\\
    \ccsasg(\literal P) = ( \coaction{\literal{fork}} \ccspar \literal{P_A} \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
  \end{matrix}
}{
  \literal P \step{τ}_\ccs ( \ccsnull \ccspar \literal a \ccspar \literal{P_B} ) \ccsrestrict \set{\literal{fork}}
}
$$
:::

{{< noindent >}} Non-determinism like in $\literal P$ of @exm-ts can be understood as a natural phenomenon in models with concurrency.
The model leaves unspecified which of two processes will consume an internal resource and, to the outsider, it is transparent which one took the resource until they communicate.
There are other ways how non-determinism plays a crucial role in models, for instance, as consequence of abstraction or parts that are left open in specifications.

The second process $\literal Q$ of @exm-ts can be understood as a deterministic sibling of $\literal P$.

::: {#exm-deterministic-phil}
#### Deterministic Philosophers

A process matching the transitions from $\literal Q$ in @exm-ts would be the following, where the philosophers take the fork as a team and then let the environment choose who of them eats:

$$
\literal Q ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
$$

:::

## Behavioral Equivalences {#sec-behavioral-eq}

### Trace Equivalence

::: {#def-traces}
#### Traces

The set of traces of a process $\traces{p}$ is recursively defined as

- $\emptyword ∈ \traces{p}$,^[We denote the empty word by $\emptyword$.]
- $α \cdot \vec w ∈ \traces{p}$ if there is $p'$ with $p \step α p'$ and $\vec w ∈ \traces{p'}$.

:::

::: {#def-trace-eq}
#### Trace Equivalence

Two processes $p$ and $q$ are considered *trace-equivalent*, written $p \beq{T} q$, if $\traces{p} = \traces{q}$.

Processes are *trace-preordered*, $p \bpreord{T} q$, if $\traces{p} ⊆ \traces{q}$.
:::

::: {#exm-phil-traces}

The traces for the processes of @exm-ts would be $\traces{\literal{P}} = \set{\emptyword, τ, τ\literal{a}, τ\literal{b}} = \traces{\literal Q}$. Consequently, $\literal P$ and $\literal Q$ are trace-equivalent, $\literal P \beq{T} \literal Q$.

As $\traces{\literal{p_a}} = \set{\emptyword, \literal{a}} ⊆ \set{\emptyword, \literal{a}, \literal{b}} = \traces{\literal{q_{ab}}}$, $\literal{p_a}$ is trace-preordered to $\literal{q_{ab}}$, $\literal{p_a} \bpreord{T} \literal{q_{ab}}$.
This ordering is strict, that is, $\literal{q_{ab}} \nbpreord{T} \literal{p_a}$, due to $\literal{b} ∈ \traces{\literal{q_{ab}}}$ but $\literal{b} \notin \traces{\literal{p_a}}$.
We could say that trace $\literal{b}$ constitutes a *difference* between $\literal{q_{ab}}$ and $\literal{p_a}$.
:::

::: {#prp-trace-eq-rel}
The trace preorder $\bpreord{T}$ is indeed a preorder (i.e., transitive and reflexive) and trace equivalence $\beq{T}$ is indeed an equivalence relation (i.e., transitive, reflexive, and moreover symmetric).
:::
::: {.proof}
The properties carry over directly from $⊆$ and $=$ on sets of $\traces{\cdot}$.
:::

### Simulation and Bisimulation

::: {#def-simulation}
#### Simulation

A relation on states, $\rel R ⊆ \states × \states$, is called a *simulation* if, for each $(p, q) ∈ \rel R$ and $α ∈ \actions$ with $p \step a p'$ there is a $q'$ with $q \step α q'$ and $(p', q') ∈ \rel R$.

:::

::: {#def-bisimilarity}
#### (Bi-)similarity

Simulation-preorder, similarity and bisimilarity are defined as follows:

- $p$ is *simulated by* $q$, $p \bpreord{S} q$, iff there is a simulation $\rel R$ with $(p, q) ∈ \rel R$.
- $p$ is *similar* to $q$, $p \beq{S} q$, iff $p \bpreord{S} q$ and $q \bpreord{S} p$.
- $p$ is *bisimilar* to $q$, $p \beq{B} q$, iff there is a *symmetric* simulation $\rel R$ (i.e. $\rel R = \inverse{\rel R}$) with $(p, q) ∈ \rel R$.
:::

::: {#exm-phil-sim}

The following relations are simulations on the LTS of @exm-ts:

- the empty relation $\rel R_\varnothing ≔ \varnothing$;
- the identity relation $\rel R_\mathrm{id} ≔ \identity{\set{\literal P, \literal{p_a}, \literal{p_b}, \literal{p_1}, \literal{p_2}, \literal Q, \literal{q_{ab}}, \literal{q_1}, \literal{q_2}}} = \set{(\literal P, \literal P),\allowbreak (\literal{p_a}, \literal{p_a}),\allowbreak (\literal{p_b}, \literal{p_b}), (\literal{p_1}, \literal{p_1}),\allowbreak (\literal{p_2}, \literal{p_2}), (\literal Q, \literal Q), (\literal{q_{ab}}, \literal{q_{ab}}), \allowbreak(\literal{q_1}, \literal{q_1}), (\literal{q_2}, \literal{q_2})}$;
- the universal relation between all final states $\rel R_\mathrm{fin} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}}²$,
- more generally, the relation from final states to all other states: $\rel R_\mathrm{up} ≔ \set{\literal{p_1}, \literal{p_2}, \literal{q_1}, \literal{q_2}} × \states$;
- a minimal simulation for $\literal P$ and $\literal Q$: $\rel R_\literal{PQ} ≔ \set{(\literal{P}, \literal{Q}), (\literal{p_a}, \literal{q_{ab}}), (\literal{p_b}, \literal{q_{ab}}), (\literal{p_1}, \literal{q_1}), (\literal{p_2}, \literal{q_2})}$;
- and the combination of the above $\rel R_\mathrm{max} ≔ \rel R_\mathrm{sim} ∪ \rel R_\mathrm{id} ∪ \rel R_\mathrm{up}$.

{{<noindent>}} The simulation $\rel R_\literal{PQ}$ shows that $\literal P \bpreord{S} \literal Q$.

However, there is no simulation that preorders $\literal Q$ to $\literal P$, as there is no way to simulate the transition $\literal Q \step{τ} \literal{q_{ab}}$ from $\literal P$ for lack of a successor that allows $\literal a$ *and* $\literal b$ as does $\literal{q_{ab}}$.
(In @sec-hml, we will discuss how to capture such differences more formally.)

Thus, $\literal Q \nbpreord{S} \literal P$, and $\literal P \nbeq{S} \literal Q$. Moreover, there cannot be a symmetric simulation, $\literal P \nbeq{B} \literal Q$.
:::

::: {#prp-sim-eq-rel}
The simulation preorder $\bpreord{S}$ is indeed a preorder and $\beq{S}$ and $\beq{B}$ are equivalences.
:::
::: {.proof}
1. Reflexivity of $\bpreord{S}$, $\beq{S}$ and $\beq{B}$:<br>
  $\identity{\states}$ is a (symmetric) simulation on each transition system.
2. Transitivity of $\bpreord{S}$:<br>
  If $\rel R_1$ and $\rel R_2$ are simulations, then the composition $\rel R_1 \circ \rel R_2$ too is a simulation.
  This also establishes transitivity of $\beq{S}$ and $\beq{B}$.
3. Symmetry of $\beq{S}:$ By definition.
4. Symmetry of $\beq{B}$:<br>
  $p \beq{B} q$ implies there is a symmetric simulation $\rel R$ with $(p,q) ∈ \rel R$.
  As $\rel R = \inverse{\rel R}$, this implies $(q,p) ∈ \rel R$ and thus $q \beq{B} p$.

:::

### The Hierarchy of Equivalences {#sec-hierarchy-equivalences}

Bisimilarity, similarity and trace equivalence form a small hierarchy of equivalences in the sense that they imply one-another in one direction, but not in the other.
Let us quickly make this formal:

:::: {#fig-core-hierarchy .column-margin}
```{mermaid}
  flowchart TD
    GI[Graph Isomorphism] -.-> B[Bisimilarity] --> S[Similarity] --> T[Trace Equivalence]
    style GI stroke-dasharray: 3 3
  ```

  Core hierarchy of equivalences.
::::



::: {#lem-bisim-bisim}
  The relation $\beq{B}$ is itself a symmetric simulation.
:::

::: {#cor-bisim-impl-sim}
  If $p \beq{B} q$, then $p \beq{S} q$.
:::

::: {#lem-sim-impl-traces}
  If $p \bpreord{S} q$, then $p \bpreord{T} q$. (Consequently, $p \beq{S} q$ also implies $p \beq{T} q$.)
:::

{{<noindent>}} We also have seen with example @exm-phil-sim that this hierarchy is strict between trace and simulation preorder in the sense that there exist $p,q$ with $p \bpreord{T} q$ but not $p \bpreord{S} q$.
The hierarchy also is strict between similarity and bisimilarity as the following example shows.

::: {#exm-bisim-sim}
#### Trolled philosophers

  Let us extend @exm-deterministic-phil with a troll process that might consume the $\literal{fork}$ and then do nothing:
  $$
  \literal {Q'} ≔ (\coaction{\literal{fork}} \ccspar \ccsprefix{\literal{fork} \ccspar \literal{fork}} ( \literal{a} \ccschoice \literal{b} )) \ccsrestrict \set{\literal{fork}}.
  $$
  This adds another deadlock state to the transition system, seen in @fig-bisim-sim-ts.

:::: {#fig-bisim-sim-ts .column-margin}
  ```{mermaid}
  flowchart TD
    q0([Q']) -- τ --> qAB([q<sub>ab</sub>])
    qAB -- a --> qA([q<sub>1</sub>])
    qAB -- b --> qB([q<sub>2</sub>])
    q0 -- τ --> qT([q<sub>3</sub>])
  ```
  Example with new deadlock $\literal{q_3}$.
::::

  To similarity, this change is invisible, that is $\literal Q \beq{S} \literal{Q'}$.
  (Reason: The relation $\set{(\literal Q, \literal{Q'}), (\literal{Q'}, \literal{Q})} \cup \identity{\set{ \literal{q_{ab}}, \literal{q_1}, \literal{q_2}, \literal{q_3}}}$ is a simulation.)

  However, to bisimilarity, $\literal{Q'} \step{τ} \literal{q_3}$ constitutes a difference.
  There cannot be a symmetric simulation handling this transition as $\literal{Q}$ has no deadlocked successors.
  Thus $\literal Q \nbeq{B} \literal{Q'}$.
:::

The equivalences we have been discussed so far could also be understood as abstractions of an even finer equivalence, namely graph isomorphism:

::: {#def-graph-isomorphism}
#### Graph Isomorphism

A bijective function $\rel f \colon \states \to \states$ is called a *graph isomorphism* on a transition system if, for all $p,p', α$, the transition $p \step{α} p'$ exists if and only if the transition $\rel f(p) \step{α} \rel f(p')$ exists.

Two states $p$ and $q$ are considered *graph-isomorphism-equivalent*, $p \beq{GI} q$, iff there is a graph isomorphism $\rel f$ with $\rel f(p) = q$.
:::

::: {#exm-graph-isomorphism}
Consider the transition system in @fig-iso-ts.
$\literal{p_{even}} \beq{GI} \literal{p_{odd}}$ because $\rel f ≔ \set{\literal{p_{even}} \mapsto \literal{p_{odd}}, \literal{p_{odd}} \mapsto \literal{p_{even}}}$ is a graph isomorphism.

:::: {#fig-iso-ts .column-margin}
  ```{mermaid}
  flowchart TD
    pEven([p<sub>even</sub>]) -- τ --> pOdd([p<sub>odd</sub>]) -- τ --> pEven
  ```
  Transition system with an isomorphic cycle.
::::
:::

::: {#lem-iso-impl-bisim}
The relation $\beq{GI}$ is itself a symmetric simulation and thus $p \beq{GI} q$ implies $p \beq{B} q$.
:::

Once again, the hierarchy is strict because of bisimilarity being less restricted in the matching of equivalent states.

::: {#exm-iso-vs-bisim}
Consider the processes $\literal{P_1} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $\literal{P_2} ≔ (\coaction{\literal{fork}} \ccspar \literal{fork} \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$.
$\literal{P_1}$ can transition to $(\ccsnull \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$, while $\literal{P_2}$ has two options, namely $(\ccsnull \ccspar \ccsnull \ccspar \literal{fork}) \ccsrestrict \set{\literal{fork}}$ and $(\ccsnull \ccspar \literal{fork} \ccspar \ccsnull) \ccsrestrict \set{\literal{fork}}$.
All three reachable processes are deadlocks and thus isomorphic.
But $\literal{P_1} \nbeq{GI} \literal{P_2}$ because no bijection can connect the one successor of $\literal{P_1}$ and the two of $\literal{P_2}$.
However, $\literal{P_1} \beq{B} \literal{P_2}$, as bisimilarity is more relaxed.
:::



## Modal Logic {#sec-hml}

### Hennessy–Milner Logic to Express Observations

::: {#def-hml}
#### Hennessy–Milner Logic

Formulas of *Hennessy–Milner logic* $\hml$ are given by the grammar:

$$
\begin{array}{rcllr}
  φ & \grammardef &
    \hmlobs{α}φ & \quad\text{with } α ∈ \actions &
      \text{“observation”} \\
    & \grammaror & \hmland{i}{I}φ_i & \quad\text{with index set } I & \text{“conjunction”} \\
    & \grammaror & \hmlneg φ & & \text{“negation”} \\
\end{array}
$$
:::

{{<noindent>}} We also write conjunctions as sets $\hmlands \set{φ_1, φ_2…}$.
The empty conjunction $\hmlands \varnothing$ is denoted by $\hmltrue$ and serves as the nil-element of HML syntax trees.
We also usually omit them when writing down formulas, e.g., shortening $\hmlobs{\literal a}\hmlobs{\literal b}\hmltrue$ to $\hmlobs{\literal a}\hmlobs{\literal b}$.

The intuition behind HML is that it describes *what sequences of behavior* one may or may not *observe* of a system.
Observations $\hmlobs{α}…$ are used to build up possible action sequences;
conjunctions $\hmlands\set{…}$ capture branching points in decision trees;
and negations $\hmlneg …$ describe impossibilities.

::: {#def-hml-semantics}
#### HML semantics
The semantics of HML $\semantics{\cdot} \colon \hml → \powerset{\states}$ is defined recursively by:

$$
\begin{array}{rcl}
  \semantics{\hmlobs{α}φ} & ≔ & \set{p \mid \exists p' ∈ \semantics{φ} \ldotp p \step α p'},\\
  \semantics{\hmland{i}{I}φ_i} & ≔ & \bigcap_{i ∈ I} \semantics{φ_i},\\
  \semantics{\hmlneg φ} & ≔ & \states \setminus \semantics{φ}.
\end{array}
$$
:::

::: {#exm-hml}

Let us consider some observations on the system of @exm-ts.

- $\semantics{\hmlobs{τ}\hmlobs{\literal a}} = \set{\literal P, \literal Q}$ as both, $\literal P$ and $\literal Q$, expose the trace $τ\literal{a}$,
- $\literal Q ∈ \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$, but $\literal P \notin \semantics{\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}}$.
- $\literal P ∈ \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$, but $\literal Q \notin \semantics{\hmlobs{τ}\hmlneg\hmlobs{\literal a}}$.

:::

### Characterizing Bisimilarity via HML

::: {#def-distinctions}
#### Distinctions and Equivalences

We say that formula $φ ∈ \hml$ *distinguishes* state $p$ *from* state $q$ if $p ∈ \semantics{φ}$ but $q \notin \semantics{φ}$.

We say a sublogic $\observationsvar{} ⊆ \hml$ *preorders* state $p$ to $q$, $p \bpreordvar{\observationsvar{}} q$, if no $φ ∈ \observationsvar{}$ is distinguishing $p$ from $q$.
If the preordering goes in both directions, we say that $p$ and $q$ are equivalent with respect to sublogic $\observationsvar{}$, written $p \beqvar{\observationsvar{}} q$.
:::

{{<noindent>}} By this account, $\hmlobs{τ}\hmlneg\hmlobs{\literal a}$ of @exm-hml distinguishes $\literal P$ from $\literal Q$.
$\hmlobs{τ}\hmlands\set{\hmlobs{\literal a}, \hmlobs{\literal b}}$, on the other hand, distinguishes $\literal Q$ from $\literal P$.
(The direction matters!)
For instance, the sublogic $\set{\hmlobs{τ}\hmlobs{\literal a}, \hmlobs{τ}\hmlobs{\literal b}}$ preorders $\literal P$ and $\literal Q$ in both directions; so the two states are equivalent with respect to this logic.


::: {#prp-hml-eq}
Consider an arbitrary HML sublogic $\observationsvar{} ⊆ \hml$.
Then, $\bpreordvar{\observationsvar{}}$ is a preorder,
and $\beqvar{\observationsvar{}}$ an equivalence relation.
:::

::: {#lem-hml-eq-sim}
Hennessy–Milner logic equivalence $\beqvar{\hml}$ is a simulation relation.
:::
::: {.proof}
Assume it were not.
Then there would need to be $p \beqvar{\hml} q$ with step $p \step α p'$, and no $q'$ such that $q \step α q'$ and $p' \beqvar{\hml} q'$.
So there would need to be a distinguishing formula $φ_{q'}$ for each $q'$ that $q$ can reach by an $α$-step.
Consider the formula $φ_α ≔ \hmlobs{α}\hmland{q'}{\set{q' \mid q \step α q'}} φ_{q'}$.
It must be true for $p$ and false for $q$, contradicting $p \beqvar{\hml} q$.
:::


::: {#lem-hml-eq-bisim-invariant}
#### HML Bisimulation Invariance

If $p ∈ \semantics{φ}$ and $p \beq{B} q$ then $q ∈ \semantics{φ}$.
:::
::: {.proof}
Induct over the structure of $φ$ with arbitrary $p$ and $q$.

- Case $p ∈ \semantics{\hmlobs{α}φ}$.
  Thus there is $p' ∈ \semantics{φ}$ with $p \step α p'$.
  Because $\beq{B}$ is a simulation according to @lem-bisim-bisim, this implies $q'$ with $p' \beq{B} q'$.
  The induction hypothesis makes $p' ∈ \semantics{φ}$ entail $q' ∈ \semantics{φ}$
  and thus $q ∈ \semantics{\hmlobs{α}φ}$.
- Case $p ∈ \semantics{\hmland{i}{I}φ_i}$.
  The induction hypothesis on the $φ_i$ directly leads to
  $q ∈ \semantics{\hmland{i}{I}φ_i}$.
- Case $p ∈ \semantics{\hmlneg φ}$.
  Symmetry of $\beq{B}$ accoding to @prp-sim-eq-rel, implies $q \beq{B} p$.
  By induction hypothesis, $q ∈ \semantics{φ}$ implies $p ∈ \semantics{φ}$.
  So, using contraposition, the case implies $q ∈ \semantics{\hmlneg φ}$.
:::

Combining the bisimulation invariance for one direction and that $\beq{\hml}$ is symmetric (@prp-hml-eq) simulation (@lem-hml-eq-sim) for the other, we obtain that $\hml$ precisely characterizes bisimilarity:

::: {#lem-hennessy-milner}
#### Hennessy–Milner Theorem

Bisimilarity and HML equivalence coincide, that is, $p \beq{B} q$ precisely if $p \beq{\hml} q$
:::

::: {#rem-image-finiteness}
In the standard presentation of the theorem, image finiteness of the transition system is assumed.
This means that $p \step α \cdot$ is finite for every $p ∈ \states$.
The amount of outgoing transitions matters precisely in the construction of $φ_α$ in the proof of @lem-hml-eq-sim.
But as our definition of $\hml$ (@def-hml) allows infinite conjunctions $\hmland{i}{I} …$, we do not need an assumption here.
The implicit assumption is that the cardinality of index sets $I$ can match that of $p \step α \cdot$.
The original proof by @hm1980hml uses binary conjunction and thus can only express finitary conjunctions.
:::


## Games {#sec-games}

### Reachability Games

*Gale--Stewart-style reachability games* where the defender wins all infinite plays.

::: {#def-game}
#### Reachability Game

A *reachability game* $\game = (G, G_\defender, \gamemoveblank)$ is played on a directed graph consisting of

- a set of *game positions* $G$, partitioned into
  - *defender positions* $G_\defender ⊆ G$
  - and *attacker positions* $G_\attacker ≔ G \setminus G_\defender$,
- and a set of *game moves* ${\gamemoveblank} ⊆ G × G$.

{{<noindent>}} We denote by $\game[g_0]$ the game played from starting position $g_0 ∈ G$.
:::


::: {#def-game-plays}
#### Plays and Wins

We call the paths ${g_0}{g_1} … ∈ G^{\infty}$ with $g_{i} \gamemoveblank g_{i+1}$ *plays* of $\game[g_0]$.
They may be finite or infinite.
The defender *wins* infinite plays.
If a finite play $g_{0}\dots g_{n}\!\ngamemoveblank$ is stuck, the stuck player loses: The defender wins if $g_{n} ∈ G_\attacker$, and the attacker wins if $g_{n}∈ G_\defender$.
:::

::: {#def-strategies}
#### Strategies and Winning Strategies

A (positional, non-deterministic) *attacker strategy* is a subset of the moves starting in attacker states, $\rel F ⊆ (G_\attacker × G) \cap \mathord{\gamemoveblank}$.

Similarly, a *defender strategy* is a subset of the moves starting in defender states, $\rel F ⊆ (G_\defender × G) \cap \mathord{\gamemoveblank}$.
If (fairly) picking elements of strategy $\rel F$ ensures a player to win, $\rel F$ is called a *winning strategy* for this player.
The player with a winning strategy for $\game[g_{0}]$ is said to *win* $\game[g_{0}]$.
If $\rel F$ is a function on $G_\attacker$ or $G_\defender$, respectively, we call it a *deterministic* strategy.

:::

{{<noindent>}} This kind of games essentially is a subclass of parity games only colored by 0.
So the games are positionally determined.
This means, for each possible initial position, exactly one of the two players has a positional deterministic winning strategy $\rel F$.
We call this partitioning of the game positions the winning regions.

::: {#def-winning-region}
#### Winning Region

The set $W_\attacker ⊆ G$ of all positions $g$ where the attacker wins $\game[g]$ is called the *attacker winning region* of $\game$.
(The defender winning region $W_\defender$ is defined analogously.)
:::

::: {#exm-formula-game}
#### A Simple Choice

Consider the game in @fig-game-ex, where round nodes represent defender positions and rectangular ones attacker positions.
Its valid plays starting from $(\literal{1})$ are
$(\literal{1})$,
$(\literal{1})[\literal{2a}]$,
$(\literal{1})[\literal{2b}]$, and
$(\literal{1})[\literal{2a}](\literal{3})$.
The defender can win from $(\literal{1})$ with a strategy moving to $[\literal{2b}]$ where the attacker is stuck.
Moving to $[\literal{2a}]$ instead would get the defender stuck.
So, the defender winning region is $\set{(\literal{1}),[\literal{2b}]}$ and the attacker wins $\set{[\literal{2a}], (\literal{3})}$.

:::: {#fig-game-ex .column-margin}
  ```{mermaid}
  flowchart TD
    1([1]) --> 2a[2a] --> 3([3])
    1 --> 2b[2b]
  ```
  A simple game.
::::
:::

### The Semantic Game of HML



::: {#def-hml-game}
#### HML Game

For a transition system $\system = (\states,\actions,\step{})$,
the $\hml$ *game* ${\game}_\hml^{\system} = (G_\hml,G_\defender,\gamemoveblank_\hml)$ is played on $G_\hml = \states × \hml$,
where the defender controls observations and negated conjunctions,
that is $(p, \hmlobs{α}φ) ∈ G_\defender$ and
$(p,\hmlneg\hmland{i}{I}\varphi_i) ∈ G_\defender$ (for all $φ,p,I$), and the attacker controls the rest.

- The defender can perform the moves:
  $$
  \begin{array}{rclr}
      (p, \hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
      (p, \hmlneg{\hmland{i}{I}\varphi_i})
      & \gamemoveblank_\hml
      & (p, \hmlneg\varphi_i)
      & \text{ with $i ∈ I$;}
  \end{array}
  $$
- and the attacker can move:
  $$
  \begin{array}{rclr}
    (p, \hmlneg\hmlobs{α}φ)
      & \gamemoveblank_\hml
      & (p', \hmlneg φ)
      & \text{ if $p \step{α} p' \quad$ and} \\
    (p, \hmland{i}{I}\varphi_i)
      & \gamemoveblank_\hml
      & (p, \varphi_i)
      & \text{ with $i ∈ I \quad$ and} \\
    (p, \hmlneg\hmlneg φ)
      & \gamemoveblank_\hml
      & (p, φ).
      &
  \end{array}
  $$
:::

{{<noindent>}} @exm-formula-game is exactly the HML game ${\game}_\hml^{\system_\literal{PQ}}$ for formula $\hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue$ and state $\literal P$ of @exm-hml with
$(\literal{1}) ≔ (\literal{P}, \hmlobs{τ}\hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2a}] ≔ (\literal{p_a}, \hmlneg\hmlobs{\literal a}\hmltrue)$,
$[\literal{2b}] ≔ (\literal{p_b}, \hmlneg\hmlobs{\literal a}\hmltrue)$, and
$(\literal{3}) ≔ (\literal{p_1}, \hmlneg\hmltrue)$.

::: {#lem-hml-semantic-game}
The defender wins ${\game}_\hml^{\system}[(p, φ)]$ precisely if $p ∈ \semantics{φ}$.
:::